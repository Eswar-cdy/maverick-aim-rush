// Generated by Cursor AI for Maverick Aim Rush
// WebSocket client for real-time features

class WebSocketManager {
    constructor() {
        this.connections = new Map();
        this.reconnectAttempts = new Map();
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000; // Start with 1 second
    }

    connect(connectionId, url, onMessage, onError = null) {
        if (this.connections.has(connectionId)) {
            console.log(`WebSocket connection ${connectionId} already exists`);
            return this.connections.get(connectionId);
        }

        try {
            const ws = new WebSocket(url);
            this.connections.set(connectionId, ws);
            this.reconnectAttempts.set(connectionId, 0);

            ws.onopen = () => {
                console.log(`WebSocket ${connectionId} connected`);
                this.reconnectAttempts.set(connectionId, 0);
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (onMessage) {
                        onMessage(data);
                    }
                } catch (error) {
                    console.error(`Error parsing WebSocket message for ${connectionId}:`, error);
                }
            };

            ws.onclose = (event) => {
                console.log(`WebSocket ${connectionId} closed:`, event.code, event.reason);
                this.connections.delete(connectionId);
                this.attemptReconnect(connectionId, url, onMessage, onError);
            };

            ws.onerror = (error) => {
                console.error(`WebSocket ${connectionId} error:`, error);
                if (onError) {
                    onError(error);
                }
            };

            return ws;
        } catch (error) {
            console.error(`Failed to create WebSocket connection ${connectionId}:`, error);
            if (onError) {
                onError(error);
            }
            return null;
        }
    }

    attemptReconnect(connectionId, url, onMessage, onError) {
        const attempts = this.reconnectAttempts.get(connectionId) || 0;
        
        if (attempts >= this.maxReconnectAttempts) {
            console.log(`Max reconnection attempts reached for ${connectionId}`);
            return;
        }

        const delay = this.reconnectDelay * Math.pow(2, attempts); // Exponential backoff
        console.log(`Attempting to reconnect ${connectionId} in ${delay}ms (attempt ${attempts + 1})`);

        setTimeout(() => {
            this.reconnectAttempts.set(connectionId, attempts + 1);
            this.connect(connectionId, url, onMessage, onError);
        }, delay);
    }

    disconnect(connectionId) {
        const ws = this.connections.get(connectionId);
        if (ws) {
            ws.close();
            this.connections.delete(connectionId);
            this.reconnectAttempts.delete(connectionId);
        }
    }

    send(connectionId, data) {
        const ws = this.connections.get(connectionId);
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(data));
            return true;
        } else {
            console.warn(`WebSocket ${connectionId} is not connected`);
            return false;
        }
    }

    isConnected(connectionId) {
        const ws = this.connections.get(connectionId);
        return ws && ws.readyState === WebSocket.OPEN;
    }

    disconnectAll() {
        for (const [connectionId, ws] of this.connections) {
            ws.close();
        }
        this.connections.clear();
        this.reconnectAttempts.clear();
    }
}

// Workout WebSocket client
class WorkoutWebSocketClient {
    constructor() {
        this.wsManager = new WebSocketManager();
        this.connectionId = 'workout';
        this.ws = null;
        this.callbacks = {
            onSetUpdate: null,
            onHeartRateUpdate: null,
            onWorkoutPaused: null,
            onWorkoutResumed: null,
            onWorkoutState: null,
            onError: null
        };
    }

    connect(sessionId) {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.hostname;
        const port = '8000'; // Backend port
        const url = `${protocol}//${host}:${port}/ws/workout/${sessionId}/`;

        this.ws = this.wsManager.connect(
            this.connectionId,
            url,
            (data) => this.handleMessage(data),
            (error) => this.handleError(error)
        );

        return this.ws;
    }

    handleMessage(data) {
        switch (data.type) {
            case 'set_update':
                if (this.callbacks.onSetUpdate) {
                    this.callbacks.onSetUpdate(data.set);
                }
                break;
            case 'heart_rate_update':
                if (this.callbacks.onHeartRateUpdate) {
                    this.callbacks.onHeartRateUpdate(data.heart_rate);
                }
                break;
            case 'workout_paused':
                if (this.callbacks.onWorkoutPaused) {
                    this.callbacks.onWorkoutPaused(data);
                }
                break;
            case 'workout_resumed':
                if (this.callbacks.onWorkoutResumed) {
                    this.callbacks.onWorkoutResumed(data);
                }
                break;
            case 'workout_state':
                if (this.callbacks.onWorkoutState) {
                    this.callbacks.onWorkoutState(data.session);
                }
                break;
            case 'error':
                console.error('WebSocket error:', data.message);
                if (this.callbacks.onError) {
                    this.callbacks.onError(data);
                }
                break;
            default:
                console.log('Unknown WebSocket message type:', data.type);
        }
    }

    handleError(error) {
        console.error('WebSocket error:', error);
        if (this.callbacks.onError) {
            this.callbacks.onError(error);
        }
    }

    sendSetCompleted(setData) {
        return this.wsManager.send(this.connectionId, {
            type: 'set_completed',
            set: setData
        });
    }

    sendHeartRate(heartRateData) {
        return this.wsManager.send(this.connectionId, {
            type: 'heart_rate',
            heart_rate: heartRateData
        });
    }

    sendWorkoutPaused() {
        return this.wsManager.send(this.connectionId, {
            type: 'workout_paused'
        });
    }

    sendWorkoutResumed() {
        return this.wsManager.send(this.connectionId, {
            type: 'workout_resumed'
        });
    }

    onSetUpdate(callback) {
        this.callbacks.onSetUpdate = callback;
    }

    onHeartRateUpdate(callback) {
        this.callbacks.onHeartRateUpdate = callback;
    }

    onWorkoutPaused(callback) {
        this.callbacks.onWorkoutPaused = callback;
    }

    onWorkoutResumed(callback) {
        this.callbacks.onWorkoutResumed = callback;
    }

    onWorkoutState(callback) {
        this.callbacks.onWorkoutState = callback;
    }

    onError(callback) {
        this.callbacks.onError = callback;
    }

    disconnect() {
        this.wsManager.disconnect(this.connectionId);
    }

    isConnected() {
        return this.wsManager.isConnected(this.connectionId);
    }
}

// Dashboard WebSocket client
class DashboardWebSocketClient {
    constructor() {
        this.wsManager = new WebSocketManager();
        this.connectionId = 'dashboard';
        this.ws = null;
        this.callbacks = {
            onDashboardUpdate: null,
            onError: null
        };
    }

    connect(userId) {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.hostname;
        const port = '8000'; // Backend port
        const url = `${protocol}//${host}:${port}/ws/dashboard/${userId}/`;

        this.ws = this.wsManager.connect(
            this.connectionId,
            url,
            (data) => this.handleMessage(data),
            (error) => this.handleError(error)
        );

        return this.ws;
    }

    handleMessage(data) {
        switch (data.type) {
            case 'dashboard_update':
                if (this.callbacks.onDashboardUpdate) {
                    this.callbacks.onDashboardUpdate(data.data);
                }
                break;
            case 'error':
                console.error('Dashboard WebSocket error:', data.message);
                if (this.callbacks.onError) {
                    this.callbacks.onError(data);
                }
                break;
            default:
                console.log('Unknown dashboard WebSocket message type:', data.type);
        }
    }

    handleError(error) {
        console.error('Dashboard WebSocket error:', error);
        if (this.callbacks.onError) {
            this.callbacks.onError(error);
        }
    }

    requestUpdate() {
        return this.wsManager.send(this.connectionId, {
            type: 'request_update'
        });
    }

    onDashboardUpdate(callback) {
        this.callbacks.onDashboardUpdate = callback;
    }

    onError(callback) {
        this.callbacks.onError = callback;
    }

    disconnect() {
        this.wsManager.disconnect(this.connectionId);
    }

    isConnected() {
        return this.wsManager.isConnected(this.connectionId);
    }
}

// Global instances
window.workoutWebSocket = new WorkoutWebSocketClient();
window.dashboardWebSocket = new DashboardWebSocketClient();

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    window.workoutWebSocket.disconnect();
    window.dashboardWebSocket.disconnect();
});
