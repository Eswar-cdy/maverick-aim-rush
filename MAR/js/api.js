// Generated by Cursor AI for Maverick Aim Rush
// MAR/js/api.js - Helper functions for interacting with the backend API.

const API_BASE_URL = 'http://localhost:8000';

/**
 * Stores authentication tokens in localStorage.
 * @param {object} tokens - The tokens object with access and refresh properties.
 */
function storeTokens(tokens) {
    localStorage.setItem('access_token', tokens.access);
    localStorage.setItem('refresh_token', tokens.refresh);
    // Also store with old keys for backward compatibility
    localStorage.setItem('accessToken', tokens.access);
    localStorage.setItem('refreshToken', tokens.refresh);
}

/**
 * Retrieves the access token from localStorage.
 * @returns {string|null} The access token.
 */
function getAccessToken() {
    return localStorage.getItem('access_token') || localStorage.getItem('accessToken');
}

/**
 * Retrieves the refresh token from localStorage.
 * @returns {string|null} The refresh token.
 */
function getRefreshToken() {
    return localStorage.getItem('refresh_token') || localStorage.getItem('refreshToken');
}

/**
 * Clears authentication tokens from localStorage.
 */
function clearTokens() {
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
}

/**
 * Checks if the user is currently authenticated.
 * @returns {boolean} True if user has a valid access token.
 */
function isAuthenticated() {
    const token = getAccessToken();
    if (!token) return false;
    
    try {
        // Check if token is expired
        return !isTokenExpired();
    } catch (error) {
        console.error('Error checking authentication:', error);
        return false;
    }
}

/**
 * Checks if the access token is expired or about to expire.
 * @returns {boolean} True if token is expired or will expire soon.
 */
function isTokenExpired() {
    const token = getAccessToken();
    if (!token) return true;
    
    try {
        // Decode JWT token (simple base64 decode)
        const payload = JSON.parse(atob(token.split('.')[1]));
        const now = Math.floor(Date.now() / 1000);
        const expiry = payload.exp;
        
        // Consider token expired if it expires within the next 5 minutes
        return (expiry - now) < 300;
    } catch (error) {
        console.error('Error checking token expiry:', error);
        return true;
    }
}

/**
 * Attempts to refresh the access token using the refresh token.
 * @returns {boolean} True if refresh was successful, false otherwise.
 */
async function refreshToken() {
    const refreshToken = getRefreshToken();
    if (!refreshToken) {
        return false;
    }

    try {
        const response = await fetch(`${API_BASE_URL}/api/v1/auth/refresh/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ refresh: refreshToken }),
        });

        if (response.ok) {
            const newTokens = await response.json();
            storeTokens({ access: newTokens.access, refresh: newTokens.refresh }); // Use new refresh token
            return true;
        } else {
            clearTokens(); // Refresh token is invalid, clear everything
            return false;
        }
    } catch (error) {
        console.error('Error refreshing token:', error);
        return false;
    }
}

/**
 * A wrapper for the fetch API that handles authentication and token refreshing.
 * @param {string} url - The URL to fetch.
 * @param {object} options - The options for the fetch request.
 * @returns {Promise<Response>} The fetch response.
 */
async function apiFetch(url, options = {}) {
    options.headers = options.headers || {};
    const accessToken = getAccessToken();
    const hadAuthHeader = Boolean(accessToken);
    
    // Proactively refresh token if it's about to expire
    if (hadAuthHeader && isTokenExpired()) {
        console.log('üîÑ Token is about to expire, refreshing proactively...');
        const refreshed = await refreshToken();
        if (refreshed) {
            options.headers['Authorization'] = `Bearer ${getAccessToken()}`;
        } else {
            console.log('‚ùå Proactive refresh failed, clearing tokens...');
            clearTokens();
        }
    } else if (hadAuthHeader) {
        options.headers['Authorization'] = `Bearer ${accessToken}`;
    }

    // Normalize URL: prefix relative paths with API_BASE_URL so calls never hit the static server
    let requestUrl = url;
    if (!/^https?:\/\//.test(url)) {
        requestUrl = url.startsWith('/') ? `${API_BASE_URL}${url}` : `${API_BASE_URL}/${url}`;
    }

    let response = await fetch(requestUrl, options);

    if (response.status === 401) {
        console.log('üîê 401 Unauthorized - attempting token refresh...');
        // Token might be expired. Try refresh first.
        const refreshed = await refreshToken();
        if (refreshed) {
            console.log('‚úÖ Token refreshed successfully, retrying request...');
            options.headers['Authorization'] = `Bearer ${getAccessToken()}`;
            response = await fetch(requestUrl, options);
        } else {
            console.log('‚ùå Token refresh failed, clearing tokens...');
            // If refresh failed, clear tokens and retry ONCE without Authorization
            clearTokens();
            if (hadAuthHeader) {
                const headers = { ...(options.headers || {}) };
                delete headers['Authorization'];
                response = await fetch(requestUrl, { ...options, headers });
            }
        }
    }

    return response;
}

/**
 * Registers a new user.
 * @param {string} username
 * @param {string} password
 * @param {string} email
 * @returns {Promise<object>} The server response.
 */
async function register(username, password, email) {
    const response = await fetch(`${API_BASE_URL}/api/v1/auth/register/`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password, email }),
    });
    return response.json();
}


/**
 * Logs in a user and stores the tokens.
 * @param {string} username
 * @param {string} password
 * @returns {Promise<boolean>} True if login was successful.
 */
async function login(username, password) {
    try {
        const response = await fetch(`${API_BASE_URL}/api/v1/auth/login/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password }),
        });

        if (response.ok) {
            const tokens = await response.json();
            storeTokens(tokens);
            return true;
        }
        return false;
    } catch (error) {
        console.error('Login failed:', error);
        return false;
    }
}

/**
 * Logs out the user by clearing tokens.
 */
function logout() {
    clearTokens();
    // window.location.href = '/login.html'; // Example redirect
}


// --- API Functions for the Tracker App ---

/**
 * Fetches all workout sessions for the logged-in user.
 * @returns {Promise<Array>} A list of workout sessions.
 */
async function fetchSessions() {
    const response = await apiFetch('/api/v1/sessions/');
    if (!response.ok) throw new Error('Failed to fetch sessions');
    const data = await response.json();
    return Array.isArray(data) ? data : (data.results || []);
}

/**
 * Fetch exercises with optional filters.
 * @param {Object} params - e.g. { category: 'strength', recommended_for_goal: 'muscle_gain' }
 */
async function fetchExercises(params = {}) {
    const qs = new URLSearchParams(params).toString();
    const url = `/api/v1/exercises/${qs ? `?${qs}` : ''}`;
    const response = await apiFetch(url);
    if (!response.ok) throw new Error('Failed to fetch exercises');
    const data = await response.json();
    // Return the full data object for pagination and facets
    return data;
}

/**
 * Creates a new workout session.
 * @param {string} date - The date of the session (e.g., 'YYYY-MM-DD').
 * @param {number} duration_minutes - The duration of the session in minutes.
 * @returns {Promise<object>} The created session object.
 */
async function createSession(date, duration_minutes) {
    const start_time = new Date().toISOString();
    const response = await apiFetch('/api/v1/sessions/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ start_time }),
    });
    if (!response.ok) throw new Error('Failed to create session');
    return response.json();
}

/**
 * Updates an existing workout session (e.g., to set duration).
 * @param {number} session_id
 * @param {object} data - fields to update, e.g. { duration_minutes: 45 }
 */
async function updateSession(session_id, data) {
    const response = await apiFetch(`/api/v1/sessions/${session_id}/`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
    });
    if (!response.ok) throw new Error('Failed to update session');
    return response.json();
}

/**
 * Creates a new strength set for a given session.
 * @param {number} session_id
 * @param {number} exercise_id
 * @param {number} set_number
 * @param {number} reps
 * @param {number} weight_kg
 * @returns {Promise<object>} The created strength set object.
 */
async function createStrengthSet(session_id, exercise_id, set_number, reps, weight_kg) {
    const response = await apiFetch('/api/v1/strength-sets/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
            session: session_id, 
            exercise: exercise_id, 
            set_number, 
            reps, 
            weight_kg 
        }),
    });
    if (!response.ok) throw new Error('Failed to create strength set');
    return response.json();
}

/**
 * Create a cardio entry for a session.
 */
async function createCardioEntry(session_id, exercise_id, duration_minutes, distance_km) {
    const response = await apiFetch('/api/v1/cardio-entries/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ session: session_id, exercise: exercise_id, duration_minutes, distance_km }),
    });
    if (!response.ok) throw new Error('Failed to create cardio entry');
    return response.json();
}

/**
 * Fetches all nutrition logs for the logged-in user.
 * @returns {Promise<Array>} A list of nutrition logs.
 */
async function fetchNutritionLogs() {
    const response = await apiFetch('/api/v1/nutrition-logs/');
    if (!response.ok) throw new Error('Failed to fetch nutrition logs');
    return response.json();
}

/**
 * Creates a new nutrition log entry.
 * @param {object} logData - The data for the nutrition log.
 * @returns {Promise<object>} The created nutrition log object.
 */
async function createNutritionLog(logData) {
    const response = await apiFetch('/api/v1/nutrition-logs/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(logData),
    });
    if (!response.ok) throw new Error('Failed to create nutrition log');
    return response.json();
}

/**
 * User Profile API Functions
 */

/**
 * Fetches the current user's profile.
 * @returns {Promise<object>} The user profile object.
 */
async function fetchUserProfile() {
    const response = await apiFetch('/api/v1/profile/me/');
    if (!response.ok) {
        try {
            const status = response.status;
            console.warn('fetchUserProfile: non-OK response', status);
        } catch (_) {}
        return null;
    }
    return response.json();
}

/**
 * Updates the current user's profile.
 * @param {object} profileData - The profile data to update.
 * @returns {Promise<object>} The updated profile object.
 */
async function updateUserProfile(profileData) {
    const response = await apiFetch('/api/v1/profile/me/', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(profileData),
    });
    if (!response.ok) throw new Error('Failed to update user profile');
    return response.json();
}

/**
 * Auto-detects user's timezone and preferred units.
 * @returns {object} Object with timezone and unit preferences.
 */
function detectUserPreferences() {
    // Auto-detect timezone
    let timezone = 'America/New_York'; // fallback
    try {
        timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    } catch (e) {
        console.warn('Could not detect timezone, using fallback:', timezone);
    }

    // Auto-detect units based on locale
    let unitSystem = 'imperial'; // default to lb/mi
    let distanceUnit = 'mi';
    
    try {
        const locale = navigator.language || navigator.languages[0];
        // Check if user is in a metric country
        const metricCountries = ['en-AU', 'en-CA', 'en-GB', 'en-NZ', 'en-ZA', 'en-IN'];
        const isMetric = locale.includes('en-') && metricCountries.some(country => locale.includes(country)) ||
                        locale.includes('de-') || locale.includes('fr-') || locale.includes('es-') ||
                        locale.includes('it-') || locale.includes('pt-') || locale.includes('nl-') ||
                        locale.includes('sv-') || locale.includes('no-') || locale.includes('da-') ||
                        locale.includes('fi-') || locale.includes('pl-') || locale.includes('ru-') ||
                        locale.includes('ja-') || locale.includes('ko-') || locale.includes('zh-');
        
        if (isMetric) {
            unitSystem = 'metric';
            distanceUnit = 'km';
        }
    } catch (e) {
        console.warn('Could not detect locale, using imperial units');
    }

    return { timezone, unitSystem, distanceUnit };
}

/**
 * Initializes user profile with auto-detected preferences on first login.
 * @returns {Promise<object>} The user profile object.
 */
async function initializeUserProfile() {
    try {
        const preferences = detectUserPreferences();
        const profileData = {
            timezone: preferences.timezone,
            unit_system: preferences.unitSystem,
            distance_unit: preferences.distanceUnit,
        };
        
        return await updateUserProfile(profileData);
    } catch (error) {
        console.error('Failed to initialize user profile:', error);
        throw error;
    }
}

/**
 * Calculate BMI, BMR, TDEE, and macro targets.
 * @param {string} goalType - The goal type ('weight_loss', 'muscle_gain', 'maintenance', 'performance').
 * @returns {Promise<object>} The calculation results.
 */
async function calculateFitnessMetrics(goalType = 'maintenance') {
    try {
        const response = await apiFetch('/api/v1/tools/calculator/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ goal_type: goalType }),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    } catch (error) {
        console.error('Failed to calculate fitness metrics:', error);
        throw error;
    }
}

/**
 * Fetch macro targets for a specific date.
 * @param {string} date - The date in YYYY-MM-DD format.
 * @returns {Promise<object>} The macro target data.
 */
async function fetchMacroTarget(date = null) {
    try {
        const url = date ? `/api/v1/macro-targets/?date=${date}` : '/api/v1/macro-targets/';
        const response = await apiFetch(url);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data.results && data.results.length > 0 ? data.results[0] : null;
    } catch (error) {
        console.error('Failed to fetch macro target:', error);
        throw error;
    }
}

/**
 * Create or update macro targets for today.
 * @param {string} goalType - The goal type.
 * @returns {Promise<object>} The created/updated macro target.
 */
async function createMacroTarget(goalType = 'maintenance') {
    try {
        // First calculate the metrics
        const calculation = await calculateFitnessMetrics(goalType);
        
        if (calculation.error) {
            throw new Error(calculation.error);
        }

        const macros = calculation.macros;
        const today = new Date().toISOString().split('T')[0];
        
        const response = await apiFetch('/api/v1/macro-targets/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                date: today,
                calories: macros.calories,
                protein_g: macros.protein_g,
                carbs_g: macros.carbs_g,
                fat_g: macros.fat_g,
                goal_type: goalType,
                current_weight_kg: macros.weight_kg,
                current_height_cm: calculation.bmr.height_cm,
                age: calculation.bmr.age,
                activity_level: macros.activity_level
            }),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    } catch (error) {
        console.error('Failed to create macro target:', error);
        throw error;
    }
}

/**
 * Fetch calculation history.
 * @returns {Promise<Array>} Array of calculation results.
 */
async function fetchCalculationHistory() {
    try {
        const response = await apiFetch('/api/v1/calculator-results/');
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data.results || [];
    } catch (error) {
        console.error('Failed to fetch calculation history:', error);
        throw error;
    }
}

// Expose helpers to window for robustness
window.getAccessToken = window.getAccessToken || getAccessToken;
window.login = window.login || login;
window.register = window.register || register;
window.logout = window.logout || logout;
window.fetchExercises = window.fetchExercises || fetchExercises;
window.fetchSessions = window.fetchSessions || fetchSessions;
window.fetchUserProfile = window.fetchUserProfile || fetchUserProfile;
window.updateUserProfile = window.updateUserProfile || updateUserProfile;
// Periodic token refresh to prevent expiry
let tokenRefreshInterval = null;

function startTokenRefresh() {
    if (tokenRefreshInterval) return; // Already running
    
    // Refresh token every 10 minutes
    tokenRefreshInterval = setInterval(async () => {
        const token = getAccessToken();
        if (token && isTokenExpired()) {
            console.log('üîÑ Periodic token refresh...');
            await refreshToken();
        }
    }, 10 * 60 * 1000); // 10 minutes
}

function stopTokenRefresh() {
    if (tokenRefreshInterval) {
        clearInterval(tokenRefreshInterval);
        tokenRefreshInterval = null;
    }
}

// Export functions for use in other modules
window.api = {
    storeTokens,
    getAccessToken,
    getRefreshToken,
    clearTokens,
    refreshToken,
    apiFetch,
    login,
    logout,
    register,
    isAuthenticated,
    startTokenRefresh,
    stopTokenRefresh,
    isTokenExpired,
    apiFetchQueued,
    safeJson
};

/**
 * Safe JSON parsing with error handling
 * @param {Response} response - Fetch response object
 * @returns {Promise<object>} Parsed JSON or null
 */
async function safeJson(response) {
    let body = null;
    try {
        body = await response.json();
    } catch (error) {
        body = null;
    }
    
    if (!response.ok) {
        const error = new Error((body && body.message) || "Request failed");
        error.status = response.status;
        error.body = body;
        throw error;
    }
    
    return body;
}

// Make safeJson available globally
window.safeJson = safeJson;

/**
 * Get CSRF token from cookie
 * @returns {string|null} CSRF token or null
 */
function getCSRFToken() {
    const cookies = document.cookie.split(';');
    for (let cookie of cookies) {
        const [name, value] = cookie.trim().split('=');
        if (name === 'csrf_token') {
            return value;
        }
    }
    return null;
}

/**
 * Wrapper for apiFetch that queues POST/DELETE requests when offline
 * @param {string} url - The API endpoint URL
 * @param {object} options - Fetch options
 * @returns {Promise<Response>} The response or queued request ID
 */
async function apiFetchQueued(url, options = {}) {
    const method = (options.method || 'GET').toUpperCase();
    
    // Add CSRF token for write operations
    if (['POST', 'PUT', 'PATCH', 'DELETE'].includes(method)) {
        const csrfToken = getCSRFToken();
        if (csrfToken) {
            options.headers = options.headers || {};
            options.headers['X-CSRF-Token'] = csrfToken;
        }
        
        // Add idempotency key for offline queue
        if (window.offlineQueue && options.idempotencyKey) {
            options.headers = options.headers || {};
            options.headers['Idempotency-Key'] = options.idempotencyKey;
        }
    }
    
    // Only queue write operations (POST, PUT, PATCH, DELETE)
    if (['POST', 'PUT', 'PATCH', 'DELETE'].includes(method)) {
        // Check if we're online
        if (!navigator.onLine) {
            console.log(`üì¶ Offline: Queuing ${method} request to ${url}`);
            
            // Queue the request
            if (window.offlineQueue) {
                const queueId = await window.offlineQueue.queueRequest(
                    method,
                    url,
                    options.body ? JSON.parse(options.body) : null,
                    options.headers || {}
                );
                
                // Return a mock response for queued requests
                return {
                    ok: true,
                    status: 202, // Accepted
                    statusText: 'Queued for offline sync',
                    json: async () => ({ 
                        queued: true, 
                        queueId: queueId,
                        message: 'Request queued for offline sync' 
                    })
                };
            }
        }
    }
    
    // For GET requests or when online, use regular apiFetch
    return apiFetch(url, options);
}

window.initializeUserProfile = window.initializeUserProfile || initializeUserProfile;
window.calculateFitnessMetrics = window.calculateFitnessMetrics || calculateFitnessMetrics;
window.fetchMacroTarget = window.fetchMacroTarget || fetchMacroTarget;
window.createMacroTarget = window.createMacroTarget || createMacroTarget;
window.fetchCalculationHistory = window.fetchCalculationHistory || fetchCalculationHistory;