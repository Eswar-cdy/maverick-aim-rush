# Generated by Cursor AI for Maverick Aim Rush
# Views for Maverick Aim Rush â€” created by Cursor AI

from rest_framework import viewsets, generics, permissions, filters
from django.contrib.auth.models import User
from .models import (
    Goal, BodyMeasurement, ExerciseCatalog, WorkoutSession, StrengthSet,
    CardioEntry, NutritionLog, SleepLog, InjuryLog, Plan, FoodCatalog,
    Muscle, Equipment, Tag
)
from .serializers import (
    UserSerializer, GoalSerializer, BodyMeasurementSerializer, ExerciseCatalogSerializer,
    WorkoutSessionSerializer, StrengthSetSerializer, CardioEntrySerializer,
    NutritionLogSerializer, SleepLogSerializer, InjuryLogSerializer, PlanSerializer,
    FoodCatalogSerializer, MuscleSerializer, EquipmentSerializer, TagSerializer
)
from .permissions import IsOwner
from .filters import ExerciseFilter
from django.db.models import Count
from django.shortcuts import render
from rest_framework import viewsets, permissions, generics
from rest_framework.views import APIView
from rest_framework.response import Response
from .models import NutritionLog, FoodCatalog, WorkoutSession, StrengthSet, CardioEntry, ExerciseCatalog, Muscle, Equipment, Tag
from .serializers import (
    NutritionLogSerializer, FoodCatalogSerializer, WorkoutSessionSerializer,
    StrengthSetSerializer, CardioEntrySerializer, UserSerializer,
    ExerciseCatalogSerializer, MuscleSerializer, EquipmentSerializer, TagSerializer
)
from .permissions import IsOwner
from django_filters.rest_framework import DjangoFilterBackend
from .filters import ExerciseFilter
import datetime
from django.db.models import F

# The pre-defined 7-day workout plan
WEEKLY_PLAN_DATA = {
    "plan": {
        "weekly_schedule": {
            "Day_1_Chest_and_Triceps": {
                "exercises": [
                    {"name": "Bench Press", "sets": 4, "reps": "8-12"},
                    {"name": "Incline Dumbbell Press", "sets": 3, "reps": "10-15"},
                    {"name": "Cable Crossover", "sets": 3, "reps": "12-15"},
                    {"name": "Tricep Pushdown", "sets": 4, "reps": "10-15"},
                    {"name": "Overhead Tricep Extension", "sets": 3, "reps": "12-15"},
                ]
            },
            "Day_2_Back_and_Biceps": {
                "exercises": [
                    {"name": "Deadlift", "sets": 4, "reps": "5-8"},
                    {"name": "Pull Ups", "sets": 3, "reps": "To Failure"},
                    {"name": "Barbell Row", "sets": 4, "reps": "8-12"},
                    {"name": "Barbell Curl", "sets": 3, "reps": "10-12"},
                    {"name": "Hammer Curl", "sets": 3, "reps": "12-15"},
                ]
            },
            "Day_3_Legs_and_Shoulders": {
                "exercises": [
                    {"name": "Back Squat", "sets": 5, "reps": "5-8"},
                    {"name": "Leg Press", "sets": 4, "reps": "10-15"},
                    {"name": "Leg Extension", "sets": 3, "reps": "15-20"},
                    {"name": "Overhead Press", "sets": 4, "reps": "8-12"},
                    {"name": "Lateral Raise", "sets": 3, "reps": "12-15"},
                ]
            },
            "Day_4_Active_Rest": {
                "exercises": [
                    {"name": "Light Cardio (Jogging)", "sets": 1, "reps": "30 mins"},
                    {"name": "Stretching / Yoga", "sets": 1, "reps": "20 mins"},
                ]
            },
            "Day_5_Chest_and_Back": {
                "exercises": [
                    {"name": "Incline Bench Press", "sets": 4, "reps": "8-12"},
                    {"name": "Dumbbell Fly", "sets": 3, "reps": "12-15"},
                    {"name": "Lat Pulldown", "sets": 4, "reps": "10-12"},
                    {"name": "Seated Cable Row", "sets": 4, "reps": "10-12"},
                ]
            },
            "Day_6_Legs_and_Abs": {
                "exercises": [
                    {"name": "Romanian Deadlift", "sets": 4, "reps": "10-12"},
                    {"name": "Walking Lunges", "sets": 3, "reps": "20 per leg"},
                    {"name": "Calf Raise", "sets": 5, "reps": "15-20"},
                    {"name": "Hanging Leg Raise", "sets": 3, "reps": "To Failure"},
                    {"name": "Plank", "sets": 3, "reps": "60s hold"},
                ]
            },
            "Day_7_Rest": {
                "exercises": [
                    {"name": "Rest Day", "sets": "N/A", "reps": "N/A"},
                ]
            }
        }
    }
}

class WeeklyPlanView(APIView):
    """
    Provides the weekly workout plan for the authenticated user.
    For now, it returns a static, pre-defined plan.
    """
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, *args, **kwargs):
        return Response(WEEKLY_PLAN_DATA)

class RegisterView(generics.CreateAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    permission_classes = [permissions.AllowAny] # Allow anyone to register

# Progress analytics summary for the authenticated user
class ProgressStatsView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, *args, **kwargs):
        user = request.user
        # Gather sessions and related strength sets
        sessions = (
            WorkoutSession.objects
            .filter(user=user)
            .prefetch_related('strength_sets')
            .order_by('date')
        )

        # Volume trend per day (sum of reps*weight)
        volume_by_date = {}
        recent_sessions_data = []
        session_dates = []
        for s in sessions:
            if not s.date:
                continue
            date_key = s.date.isoformat() if hasattr(s.date, 'isoformat') else str(s.date)
            session_dates.append(s.date)
            total = 0
            set_count = 0
            for ss in getattr(s, 'strength_sets', []).all() if hasattr(s, 'strength_sets') else []:
                reps = ss.reps or 0
                weight = ss.weight_kg or 0
                total += reps * weight
                set_count += 1
            volume_by_date[date_key] = volume_by_date.get(date_key, 0) + total
            recent_sessions_data.append({
                'date': date_key,
                'sets': set_count,
                'volume': total,
            })

        # Sort recent sessions desc and trim
        recent_sessions_data.sort(key=lambda x: x['date'], reverse=True)
        recent_sessions = recent_sessions_data[:10]

        volume_trend = [
            { 'date': d, 'volume': volume_by_date[d] }
            for d in sorted(volume_by_date.keys())
        ]

        # Personal records: max weight per exercise
        max_by_exercise = {}
        max_date_by_exercise = {}
        for s in sessions:
            for ss in getattr(s, 'strength_sets', []).all() if hasattr(s, 'strength_sets') else []:
                ex_id = ss.exercise_id
                weight = ss.weight_kg or 0
                if ex_id not in max_by_exercise or weight > max_by_exercise[ex_id]:
                    max_by_exercise[ex_id] = weight
                    max_date_by_exercise[ex_id] = s.date

        # Resolve exercise names
        exercise_names = {}
        if max_by_exercise:
            for ex in ExerciseCatalog.objects.filter(id__in=max_by_exercise.keys()):
                exercise_names[ex.id] = ex.name
        prs = []
        for ex_id, max_w in max_by_exercise.items():
            date_val = max_date_by_exercise.get(ex_id)
            date_str = date_val.isoformat() if hasattr(date_val, 'isoformat') else str(date_val)
            prs.append({ 'exercise_id': ex_id, 'exercise': exercise_names.get(ex_id, f'Exercise #{ex_id}'), 'max_weight': max_w, 'date': date_str })
        prs.sort(key=lambda x: x['max_weight'], reverse=True)
        prs = prs[:8]  # top 8

        # Sessions per ISO week (YYYY-Www)
        sessions_per_week = {}
        for s in sessions:
            if not s.date:
                continue
            year, week, _ = s.date.isocalendar()
            key = f"{year}-W{str(week).zfill(2)}"
            sessions_per_week[key] = sessions_per_week.get(key, 0) + 1
        sessions_per_week_list = [ { 'week': k, 'count': sessions_per_week[k] } for k in sorted(sessions_per_week.keys()) ]

        # KPIs
        last7_vol = sum([v['volume'] for v in volume_trend[-7:]]) if volume_trend else 0
        sessions_this_week = sessions_per_week_list[-1]['count'] if sessions_per_week_list else 0

        # Streaks (by day)
        session_dates = sorted(set(session_dates))
        longest_streak = 0
        current_streak = 0
        prev = None
        for d in session_dates:
            if prev and (d - prev == datetime.timedelta(days=1)):
                current_streak += 1
            else:
                current_streak = 1
            longest_streak = max(longest_streak, current_streak)
            prev = d
        best_week = None
        if sessions_per_week_list:
            best_week = max(sessions_per_week_list, key=lambda x: x['count'])

        # Nutrition overlay per date
        nutrition_by_date = []
        totals = {}
        for n in NutritionLog.objects.filter(user=user).only('date', 'calories', 'protein_g'):
            key = n.date.isoformat() if hasattr(n.date, 'isoformat') else str(n.date)
            entry = totals.get(key, {'calories': 0, 'protein': 0})
            entry['calories'] += getattr(n, 'calories', 0) or 0
            entry['protein'] += getattr(n, 'protein_g', 0) or 0
            totals[key] = entry
        for k in sorted(totals.keys()):
            nutrition_by_date.append({ 'date': k, 'calories': totals[k]['calories'], 'protein': totals[k]['protein'] })

        return Response({
            'volume_trend': volume_trend,
            'prs': prs,
            'sessions_per_week': sessions_per_week_list,
            'recent_sessions': recent_sessions,
            'nutrition_by_date': nutrition_by_date,
            'kpis': {
                'total_volume_7d': last7_vol,
                'sessions_this_week': sessions_this_week,
                'current_streak': current_streak,
                'longest_streak': longest_streak,
                'best_week': best_week,
            }
        })

class ProgressExerciseTrendView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, *args, **kwargs):
        user = request.user
        ex_id = request.query_params.get('exercise_id')
        if not ex_id:
            return Response({ 'detail': 'exercise_id is required' }, status=400)
        # Build daily max weight and est 1RM trend
        trend = {}
        for s in WorkoutSession.objects.filter(user=user).prefetch_related('strength_sets').order_by('date'):
            date_key = s.date.isoformat() if hasattr(s.date, 'isoformat') else str(s.date)
            for ss in getattr(s, 'strength_sets', []).all() if hasattr(s, 'strength_sets') else []:
                if str(ss.exercise_id) != str(ex_id):
                    continue
                w = ss.weight_kg or 0
                r = ss.reps or 0
                est_1rm = w * (1 + r/30.0)
                if date_key not in trend or w > trend[date_key]['max_weight']:
                    trend[date_key] = { 'date': date_key, 'max_weight': w, 'est_1rm': est_1rm }
        series = [trend[k] for k in sorted(trend.keys())]
        return Response({ 'trend': series })

# A base viewset that automatically associates the user with the object
class BaseUserViewSet(viewsets.ModelViewSet):
    permission_classes = [permissions.IsAuthenticated, IsOwner]

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)
    
    def get_queryset(self):
        return self.queryset.filter(user=self.request.user)

class WorkoutSessionViewSet(BaseUserViewSet):
    queryset = WorkoutSession.objects.all()
    serializer_class = WorkoutSessionSerializer
    filter_backends = [filters.SearchFilter, filters.OrderingFilter]
    ordering_fields = ['date', 'duration_minutes']

class NutritionLogViewSet(BaseUserViewSet):
    queryset = NutritionLog.objects.all()
    serializer_class = NutritionLogSerializer

class MeasurementViewSet(BaseUserViewSet):
    queryset = BodyMeasurement.objects.all()
    serializer_class = BodyMeasurementSerializer

class GoalViewSet(BaseUserViewSet):
    queryset = Goal.objects.all()
    serializer_class = GoalSerializer

    def list(self, request, *args, **kwargs):
        # Include a computed progress field per goal
        response = super().list(request, *args, **kwargs)
        items = response.data
        try:
            # Resolve exercise names
            exercise_ids = [g['exercise'] for g in items if g.get('exercise')]
            ex_names = { ex.id: ex.name for ex in ExerciseCatalog.objects.filter(id__in=exercise_ids) }
            # Compute progress
            for g in items:
                metric = g.get('metric')
                target = float(g.get('target_value') or 0)
                progress = None
                if metric == 'weight_kg':
                    latest = BodyMeasurement.objects.filter(user=request.user).order_by('-date').first()
                    if latest and latest.weight_kg is not None:
                        progress = latest.weight_kg
                elif metric == 'body_fat':
                    latest = BodyMeasurement.objects.filter(user=request.user).order_by('-date').first()
                    if latest and latest.body_fat_percentage is not None:
                        progress = latest.body_fat_percentage
                elif metric == 'lift_kg':
                    ex_id = g.get('exercise')
                    if ex_id:
                        g['exercise_name'] = ex_names.get(ex_id)
                        best = 0
                        for s in WorkoutSession.objects.filter(user=request.user).prefetch_related('strength_sets'):
                            for ss in s.strength_sets.all():
                                if ss.exercise_id == ex_id and (ss.weight_kg or 0) > best:
                                    best = ss.weight_kg or 0
                        progress = best
                g['current_value'] = progress
                # ETA calculation
                if progress is not None and target:
                    g['percent'] = round(min(100.0, (progress / target) * 100.0), 1) if target > 0 else None
                    if metric in ('weight_kg', 'body_fat'):
                        field = 'weight_kg' if metric == 'weight_kg' else 'body_fat_percentage'
                        # Look at last 30 days
                        cutoff = datetime.date.today() - datetime.timedelta(days=30)
                        recent = (
                            BodyMeasurement.objects
                            .filter(user=request.user, date__gte=cutoff)
                            .order_by('date')
                            .values('date', val=F(field))
                        )
                        if len(recent) > 1:
                            start_val = recent[0]['val']
                            end_val = recent[len(recent)-1]['val']
                            if start_val is not None and end_val is not None:
                                days = (recent[len(recent)-1]['date'] - recent[0]['date']).days
                                if days > 0:
                                    rate = (end_val - start_val) / days
                                    remaining = target - end_val
                                    if (rate > 0 and remaining > 0) or (rate < 0 and remaining < 0):
                                        eta_days = abs(remaining / rate)
                                        eta_date = datetime.date.today() + datetime.timedelta(days=eta_days)
                                        g['eta'] = eta_date.isoformat()
        except Exception:
            pass
        return response

# Viewsets that are not user-specific or are read-only for all authenticated users
class ExerciseCatalogViewSet(viewsets.ReadOnlyModelViewSet):
    """This viewset provides a read-only list of all available exercises."""
    queryset = ExerciseCatalog.objects.all().prefetch_related('equipments', 'muscles').distinct()
    serializer_class = ExerciseCatalogSerializer
    permission_classes = [permissions.AllowAny]
    filterset_class = ExerciseFilter
    search_fields = ['name', 'description']
    ordering_fields = ['name', 'difficulty_level']

    def list(self, request, *args, **kwargs):
        # Apply filters/search/order via DRF machinery
        queryset = self.filter_queryset(self.get_queryset())

        # Compute facets on the filtered (but unpaginated) queryset
        equipment_counts_qs = queryset.values('equipments__name').annotate(count=Count('id')).order_by('-count')
        muscle_counts_qs = queryset.values('muscles__name').annotate(count=Count('id')).order_by('-count')
        equipment_counts = [
            { 'name': row['equipments__name'] or 'Unspecified', 'count': row['count'] }
            for row in equipment_counts_qs
            if row['equipments__name'] is not None
        ]
        muscle_counts = [
            { 'name': row['muscles__name'] or 'Unspecified', 'count': row['count'] }
            for row in muscle_counts_qs
            if row['muscles__name'] is not None
        ]

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            response = self.get_paginated_response(serializer.data)
            # Inject facets into paginated envelope
            response.data['facets'] = {
                'equipments': equipment_counts,
                'muscles': muscle_counts,
            }
            return response

        serializer = self.get_serializer(queryset, many=True)
        # Non-paginated fallback shape mirrors paginated 'results'
        return Response({
            'count': len(serializer.data),
            'next': None,
            'previous': None,
            'results': serializer.data,
            'facets': {
                'equipments': equipment_counts,
                'muscles': muscle_counts,
            }
        })


class MuscleViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Muscle.objects.all()
    serializer_class = MuscleSerializer
    permission_classes = [permissions.AllowAny]

class EquipmentViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Equipment.objects.all()
    serializer_class = EquipmentSerializer
    permission_classes = [permissions.AllowAny]

class TagViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Tag.objects.all()
    serializer_class = TagSerializer
    permission_classes = [permissions.AllowAny]

class FoodCatalogViewSet(viewsets.ReadOnlyModelViewSet):
    """Read-only list/search of foods with nutrition per 100g."""
    queryset = FoodCatalog.objects.all()
    serializer_class = FoodCatalogSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        qs = super().get_queryset()
        q = self.request.query_params.get('q')
        if q:
            qs = qs.filter(name__icontains=q)
        return qs

# These viewsets are for nested objects and are more tightly controlled
# For simplicity, StrengthSet and CardioEntry are created/managed via WorkoutSession
# If direct access is needed, they would look like this:
class StrengthSetViewSet(viewsets.ModelViewSet):
    serializer_class = StrengthSetSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return StrengthSet.objects.filter(session__user=self.request.user)

class CardioEntryViewSet(viewsets.ModelViewSet):
    serializer_class = CardioEntrySerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return CardioEntry.objects.filter(session__user=self.request.user)
