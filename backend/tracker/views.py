# Generated by Cursor AI for Maverick Aim Rush
# Views for Maverick Aim Rush â€” created by Cursor AI

from rest_framework import viewsets, generics, permissions, filters, status
from rest_framework.response import Response
from rest_framework.views import APIView
from django.contrib.auth.models import User
from django.contrib.auth import authenticate
from rest_framework_simplejwt.tokens import RefreshToken
from .models import (
    Goal, BodyMeasurement, ExerciseCatalog, WorkoutSession, StrengthSet,
    CardioEntry, NutritionLog, SleepLog, InjuryLog, Plan, PlannedExercise, FoodCatalog,
    Muscle, Equipment, Tag, MacroTarget, CalculatorResult, ProgressPhoto,
    PhotoComparison, BodyPartMeasurement, ProgressMilestone, MuscleGroup,
    BodyComposition, MuscleGroupMeasurement, BodyAnalytics, ProgressPrediction,
    # Enhanced Nutrition Models
    FoodCategory, Recipe, RecipeIngredient, RecipeInstruction, MealPlan, MealPlanDay,
    MealPlanMeal, MealTemplate, NutritionGoal, WaterIntake, SupplementLog, MealRating,
    GroceryList, RestaurantFood, NutritionalAnalysis, TrainerProfile, ExerciseContraindication,
    UserProfile
)
from .serializers import (
    UserSerializer, GoalSerializer, BodyMeasurementSerializer, ExerciseCatalogSerializer,
    WorkoutSessionSerializer, StrengthSetSerializer, CardioEntrySerializer,
    NutritionLogSerializer, SleepLogSerializer, InjuryLogSerializer, PlanSerializer,
    FoodCatalogSerializer, MuscleSerializer, EquipmentSerializer, TagSerializer,
    MacroTargetSerializer, CalculatorResultSerializer, ProgressPhotoSerializer,
    PhotoComparisonSerializer, BodyPartMeasurementSerializer, ProgressMilestoneSerializer,
    MuscleGroupSerializer, BodyCompositionSerializer, MuscleGroupMeasurementSerializer,
    BodyAnalyticsSerializer, ProgressPredictionSerializer,
    # Enhanced Nutrition Serializers
    FoodCategorySerializer, RecipeSerializer, RecipeIngredientSerializer, RecipeInstructionSerializer,
    MealPlanSerializer, MealPlanDaySerializer, MealPlanMealSerializer, MealTemplateSerializer,
    NutritionGoalSerializer, WaterIntakeSerializer, SupplementLogSerializer, MealRatingSerializer,
    GroceryListSerializer, RestaurantFoodSerializer, NutritionalAnalysisSerializer,
    TrainerProfileSerializer, ExerciseContraindicationSerializer, UserProfileSerializer,
    OnboardingStatusSerializer, OnboardingAnswersSerializer
)
from .permissions import IsOwner
from .filters import ExerciseFilter
from django.db.models import Count, Q, Sum
from django.shortcuts import render
from rest_framework import viewsets, permissions, generics
from rest_framework.views import APIView
from rest_framework.response import Response
from .models import NutritionLog, FoodCatalog, WorkoutSession, StrengthSet, CardioEntry, ExerciseCatalog, Muscle, Equipment, Tag
from django_filters.rest_framework import DjangoFilterBackend
import datetime
from django.db.models import F
from django.db import models, connection
from rest_framework.decorators import action
from datetime import date, timedelta, datetime
import hashlib
from django.conf import settings
from django.utils import timezone
from django.core.cache import cache
from rest_framework.throttling import ScopedRateThrottle
from django.utils.decorators import method_decorator
from django.views.decorators.http import condition
import logging

# The pre-defined 7-day workout plan
WEEKLY_PLAN_DATA = {
    "plan": {
        "weekly_schedule": {
            "Day_1_Chest_and_Triceps": {
                "exercises": [
                    {"name": "Bench Press", "sets": 4, "reps": "8-12"},
                    {"name": "Incline Dumbbell Press", "sets": 3, "reps": "10-15"},
                    {"name": "Cable Crossover", "sets": 3, "reps": "12-15"},
                    {"name": "Tricep Pushdown", "sets": 4, "reps": "10-15"},
                    {"name": "Overhead Tricep Extension", "sets": 3, "reps": "12-15"},
                ]
            },
            "Day_2_Back_and_Biceps": {
                "exercises": [
                    {"name": "Deadlift", "sets": 4, "reps": "5-8"},
                    {"name": "Pull Ups", "sets": 3, "reps": "To Failure"},
                    {"name": "Barbell Row", "sets": 4, "reps": "8-12"},
                    {"name": "Barbell Curl", "sets": 3, "reps": "10-12"},
                    {"name": "Hammer Curl", "sets": 3, "reps": "12-15"},
                ]
            },
            "Day_3_Legs_and_Shoulders": {
                "exercises": [
                    {"name": "Back Squat", "sets": 5, "reps": "5-8"},
                    {"name": "Leg Press", "sets": 4, "reps": "10-15"},
                    {"name": "Leg Extension", "sets": 3, "reps": "15-20"},
                    {"name": "Overhead Press", "sets": 4, "reps": "8-12"},
                    {"name": "Lateral Raise", "sets": 3, "reps": "12-15"},
                ]
            },
            "Day_4_Active_Rest": {
                "exercises": [
                    {"name": "Light Cardio (Jogging)", "sets": 1, "reps": "30 mins"},
                    {"name": "Stretching / Yoga", "sets": 1, "reps": "20 mins"},
                ]
            },
            "Day_5_Chest_and_Back": {
                "exercises": [
                    {"name": "Incline Bench Press", "sets": 4, "reps": "8-12"},
                    {"name": "Dumbbell Fly", "sets": 3, "reps": "12-15"},
                    {"name": "Lat Pulldown", "sets": 4, "reps": "10-12"},
                    {"name": "Seated Cable Row", "sets": 4, "reps": "10-12"},
                ]
            },
            "Day_6_Legs_and_Abs": {
                "exercises": [
                    {"name": "Romanian Deadlift", "sets": 4, "reps": "10-12"},
                    {"name": "Walking Lunges", "sets": 3, "reps": "20 per leg"},
                    {"name": "Calf Raise", "sets": 5, "reps": "15-20"},
                    {"name": "Hanging Leg Raise", "sets": 3, "reps": "To Failure"},
                    {"name": "Plank", "sets": 3, "reps": "60s hold"},
                ]
            },
            "Day_7_Rest": {
                "exercises": [
                    {"name": "Rest Day", "sets": "N/A", "reps": "N/A"},
                ]
            }
        }
    }
}

def _plan_etag(request, *args, **kwargs):
    """
    Generate ETag based on user, profile version, and last update.
    Client sends If-None-Match; if match, Django returns 304 Not Modified.
    """
    u = request.user
    
    # Handle unauthenticated users
    if not u.is_authenticated:
        # Return a static ETag for anonymous users
        return hashlib.md5(b"anonymous_user").hexdigest()
    
    try:
        # Get profile (UserProfile or TrainerProfile)
        profile = getattr(u, 'tracker_profile', None)
        trainer = getattr(u, 'trainer_profile', None)
        
        # Compute version from profile updates
        profile_updated = u.date_joined
        if profile and hasattr(profile, 'id'):
            # Use profile ID as part of version
            profile_updated = timezone.now()
        
        # Create unique key: user_id:timestamp:goal
        goal = getattr(profile, 'primary_goal', 'general_fitness') if profile else 'general_fitness'
        frequency = getattr(profile, 'workout_frequency', 4) if profile else 4
        key = f"{u.pk}:{profile_updated.isoformat()}:{goal}:{frequency}"
        
    except Exception:
        # Fallback to user ID + join date
        key = f"{u.pk}:{u.date_joined.isoformat()}"
    
    return hashlib.md5(key.encode()).hexdigest()


@method_decorator(condition(etag_func=_plan_etag), name='dispatch')
class WeeklyPlanView(APIView):
    """
    Weekly workout plan endpoint with ETag caching.
    
    Returns PPL (Push/Pull/Legs) split by default, scaled to user's frequency.
    
    HTTP Caching:
    - Client sends: If-None-Match: "<etag>"
    - Server returns: 304 Not Modified (if ETag matches) OR 200 OK (with fresh ETag)
    
    Contract:
    {
      "week_start": "2025-10-03",
      "split": "PPL",
      "days": {
        "Day1": [{"id": "bench_press", "name": "Bench Press", "sets": [...]}],
        "Day2": [...],
        ...
      },
      "plan_version": 1,
      "meta": {"goal": "muscle_gain", "frequency": 4, ...}
    }
    """
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        user = request.user
        plan = self._build_ppl_plan(user)
        return Response(plan)
    
    def _build_ppl_plan(self, user):
        """
        Generate PPL plan based on user profile.
        
        Scaling logic:
        - 3 days: Push, Legs, Pull
        - 4 days: Push, Legs, Pull, Upper (accessories)
        - 5 days: Push, Pull, Legs, Upper, Conditioning
        - 6 days: Push, Pull, Legs (repeat with lower volume)
        """
        from .models import UserProfile, TrainerProfile
        
        # Get user preferences
        try:
            profile = user.tracker_profile
            goal = profile.primary_goal or 'general_fitness'
            frequency = profile.workout_frequency or 4
            level = profile.fitness_level or 'intermediate'
            equipment = (profile.available_equipment or '').split(',')
        except UserProfile.DoesNotExist:
            goal = 'general_fitness'
            frequency = 4
            level = 'intermediate'
            equipment = []
        
        # Get trainer overrides if available
        try:
            trainer = user.trainer_profile
            split = trainer.split or 'PPL'
            frequency = trainer.days_per_week or frequency
        except TrainerProfile.DoesNotExist:
            split = 'PPL'
        
        # Calculate week start (Monday)
        today = datetime.now().date()
        week_start = today - timedelta(days=today.weekday())
        
        # Build PPL days
        days = {}
        
        # Day 1: Push (Chest, Shoulders, Triceps)
        days['Day1'] = [
            {
                'id': 'bench_press',
                'name': 'Barbell Bench Press',
                'sets': [
                    {'reps': 8, 'weight': 60, 'rpe': 8, 'unit': 'kg'},
                    {'reps': 8, 'weight': 60, 'rpe': 8, 'unit': 'kg'},
                    {'reps': 8, 'weight': 60, 'rpe': 8, 'unit': 'kg'},
                    {'reps': 8, 'weight': 60, 'rpe': 8, 'unit': 'kg'}
                ],
                'category': 'push',
                'type': 'main'
            },
            {
                'id': 'incline_db_press',
                'name': 'Incline Dumbbell Press',
                'sets': [
                    {'reps': 10, 'weight': 22.5, 'rpe': 7, 'unit': 'kg'},
                    {'reps': 10, 'weight': 22.5, 'rpe': 7, 'unit': 'kg'},
                    {'reps': 10, 'weight': 22.5, 'rpe': 7, 'unit': 'kg'}
                ],
                'category': 'push',
                'type': 'accessory'
            },
            {
                'id': 'cable_fly',
                'name': 'Cable Fly',
                'sets': [
                    {'reps': 12, 'weight': 15, 'rpe': 6, 'unit': 'kg'},
                    {'reps': 12, 'weight': 15, 'rpe': 6, 'unit': 'kg'},
                    {'reps': 12, 'weight': 15, 'rpe': 6, 'unit': 'kg'}
                ],
                'category': 'push',
                'type': 'accessory'
            },
            {
                'id': 'overhead_press',
                'name': 'Overhead Press',
                'sets': [
                    {'reps': 8, 'weight': 40, 'rpe': 7, 'unit': 'kg'},
                    {'reps': 8, 'weight': 40, 'rpe': 7, 'unit': 'kg'},
                    {'reps': 8, 'weight': 40, 'rpe': 7, 'unit': 'kg'}
                ],
                'category': 'push',
                'type': 'accessory'
            },
            {
                'id': 'tricep_pushdown',
                'name': 'Tricep Pushdown',
                'sets': [
                    {'reps': 12, 'weight': 20, 'rpe': 6, 'unit': 'kg'},
                    {'reps': 12, 'weight': 20, 'rpe': 6, 'unit': 'kg'},
                    {'reps': 12, 'weight': 20, 'rpe': 6, 'unit': 'kg'}
                ],
                'category': 'push',
                'type': 'finisher'
            }
        ]
        
        # Day 2: Pull (Back, Biceps)
        days['Day2'] = [
            {
                'id': 'deadlift',
                'name': 'Deadlift',
                'sets': [
                    {'reps': 5, 'weight': 100, 'rpe': 8, 'unit': 'kg'},
                    {'reps': 5, 'weight': 100, 'rpe': 8, 'unit': 'kg'},
                    {'reps': 5, 'weight': 100, 'rpe': 8, 'unit': 'kg'},
                    {'reps': 5, 'weight': 100, 'rpe': 8, 'unit': 'kg'}
                ],
                'category': 'pull',
                'type': 'main'
            },
            {
                'id': 'pull_up',
                'name': 'Pull-Ups',
                'sets': [
                    {'reps': 8, 'weight': 0, 'rpe': 7, 'unit': 'kg'},
                    {'reps': 8, 'weight': 0, 'rpe': 7, 'unit': 'kg'},
                    {'reps': 8, 'weight': 0, 'rpe': 7, 'unit': 'kg'}
                ],
                'category': 'pull',
                'type': 'accessory'
            },
            {
                'id': 'barbell_row',
                'name': 'Barbell Row',
                'sets': [
                    {'reps': 8, 'weight': 60, 'rpe': 7, 'unit': 'kg'},
                    {'reps': 8, 'weight': 60, 'rpe': 7, 'unit': 'kg'},
                    {'reps': 8, 'weight': 60, 'rpe': 7, 'unit': 'kg'}
                ],
                'category': 'pull',
                'type': 'accessory'
            },
            {
                'id': 'barbell_curl',
                'name': 'Barbell Curl',
                'sets': [
                    {'reps': 10, 'weight': 25, 'rpe': 6, 'unit': 'kg'},
                    {'reps': 10, 'weight': 25, 'rpe': 6, 'unit': 'kg'},
                    {'reps': 10, 'weight': 25, 'rpe': 6, 'unit': 'kg'}
                ],
                'category': 'pull',
                'type': 'finisher'
            }
        ]
        
        # Day 3: Legs
        days['Day3'] = [
            {
                'id': 'squat',
                'name': 'Barbell Squat',
                'sets': [
                    {'reps': 6, 'weight': 80, 'rpe': 8, 'unit': 'kg'},
                    {'reps': 6, 'weight': 80, 'rpe': 8, 'unit': 'kg'},
                    {'reps': 6, 'weight': 80, 'rpe': 8, 'unit': 'kg'},
                    {'reps': 6, 'weight': 80, 'rpe': 8, 'unit': 'kg'}
                ],
                'category': 'legs',
                'type': 'main'
            },
            {
                'id': 'leg_press',
                'name': 'Leg Press',
                'sets': [
                    {'reps': 12, 'weight': 120, 'rpe': 7, 'unit': 'kg'},
                    {'reps': 12, 'weight': 120, 'rpe': 7, 'unit': 'kg'},
                    {'reps': 12, 'weight': 120, 'rpe': 7, 'unit': 'kg'}
                ],
                'category': 'legs',
                'type': 'accessory'
            },
            {
                'id': 'leg_curl',
                'name': 'Leg Curl',
                'sets': [
                    {'reps': 12, 'weight': 40, 'rpe': 6, 'unit': 'kg'},
                    {'reps': 12, 'weight': 40, 'rpe': 6, 'unit': 'kg'},
                    {'reps': 12, 'weight': 40, 'rpe': 6, 'unit': 'kg'}
                ],
                'category': 'legs',
                'type': 'accessory'
            },
            {
                'id': 'calf_raise',
                'name': 'Calf Raise',
                'sets': [
                    {'reps': 15, 'weight': 60, 'rpe': 6, 'unit': 'kg'},
                    {'reps': 15, 'weight': 60, 'rpe': 6, 'unit': 'kg'},
                    {'reps': 15, 'weight': 60, 'rpe': 6, 'unit': 'kg'}
                ],
                'category': 'legs',
                'type': 'finisher'
            }
        ]
        
        # Day 4-7: Depends on frequency
        if frequency >= 4:
            days['Day4'] = []  # Active rest
        
        if frequency >= 5:
            # Repeat Push (lighter volume)
            days['Day5'] = [ex for ex in days['Day1'][:3]]  # Take first 3 exercises
        
        if frequency >= 6:
            # Repeat Pull (lighter volume)
            days['Day6'] = [ex for ex in days['Day2'][:3]]
        
        days['Day7'] = []  # Rest
        
        # Ensure all 7 days exist
        for i in range(1, 8):
            if f'Day{i}' not in days:
                days[f'Day{i}'] = []
        
        return {
            'week_start': week_start.isoformat(),
            'split': split,
            'days': days,
            'plan_version': 1,
            'meta': {
                'goal': goal,
                'frequency': frequency,
                'level': level,
                'equipment': equipment
            }
        }

    def post(self, request, *args, **kwargs):
        """
        Expected payload (simplified):
        {
          "name": "Trainer Program (Week)",
          "start_date": "2025-09-22",
          "days": [
            {"day": "Monday", "workout": true, "exercises": ["Bench Press", "Squats"]},
            ... 7 entries ...
          ]
        }
        We will create a Plan and PlannedExercise rows accordingly.
        """
        from datetime import datetime, timedelta
        from django.db import transaction
        user = request.user
        data = request.data or {}

        name = data.get('name') or 'Trainer Program (Week)'
        start_date_str = data.get('start_date')
        try:
            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date() if start_date_str else datetime.today().date()
        except Exception:
            start_date = datetime.today().date()
        end_date = start_date + timedelta(days=6)

        days = data.get('days') or []
        day_name_to_index = {
            'Monday': 0, 'Tuesday': 1, 'Wednesday': 2, 'Thursday': 3,
            'Friday': 4, 'Saturday': 5, 'Sunday': 6
        }

        # Create plan and planned exercises
        with transaction.atomic():
            plan = Plan.objects.create(user=user, name=name, start_date=start_date, end_date=end_date)
            created = 0
            for day_pos, d in enumerate(days):
                if not d or not d.get('workout'):
                    continue
                day_name = d.get('day') or list(day_name_to_index.keys())[day_pos % 7]
                day_index = day_name_to_index.get(day_name, day_pos % 7)
                for ex_name in d.get('exercises', []):
                    try:
                        ex = ExerciseCatalog.objects.filter(name__iexact=ex_name).first()
                        if not ex:
                            continue
                        PlannedExercise.objects.create(
                            plan=plan,
                            exercise=ex,
                            day_of_week=day_index,
                            sets=None,
                            reps=None,
                        )
                        created += 1
                    except Exception:
                        continue

        return Response({
            'message': 'Weekly schedule saved',
            'plan_id': plan.id,
            'created_exercises': created,
        }, status=status.HTTP_201_CREATED)

class RegisterView(generics.CreateAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    permission_classes = [permissions.AllowAny] # Allow anyone to register

class LoginView(APIView):
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        username = request.data.get('username')
        password = request.data.get('password')
        
        if not username or not password:
            return Response(
                {'error': 'Username and password are required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        user = authenticate(username=username, password=password)
        
        if user:
            refresh = RefreshToken.for_user(user)
            return Response({
                'access': str(refresh.access_token),
                'refresh': str(refresh),
                'user': {
                    'id': user.id,
                    'username': user.username,
                    'email': user.email
                }
            })
        else:
            return Response(
                {'error': 'Invalid credentials'}, 
                status=status.HTTP_401_UNAUTHORIZED
            )

# Progress analytics summary for the authenticated user
class ProgressStatsView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, *args, **kwargs):
        user = request.user
        
        # Try to use materialized views first, fallback to ORM
        if not settings.MAR_FLAGS.get("aggregates_enabled", True):
            # Force legacy ORM path for backward compatibility
            strength_data = []
            cardio_data = []
            current_weight = None
            weight_change = None
            body_fat = None
        else:
            try:
                with connection.cursor() as cursor:
                    # Get current weight from materialized view
                    cursor.execute("""
                        SELECT current_weight, weight_change, body_fat_percentage
                        FROM tracker_weight_trend_daily 
                        WHERE user_id = %s 
                        ORDER BY date DESC 
                        LIMIT 1
                    """, [user.id])
                    weight_row = cursor.fetchone()
                    current_weight = float(weight_row[0]) if weight_row and weight_row[0] else None
                    weight_change = float(weight_row[1]) if weight_row and weight_row[1] else None
                    body_fat = float(weight_row[2]) if weight_row and weight_row[2] else None
                    
                    # Get strength summary from materialized view
                    cursor.execute("""
                        SELECT date, total_tonnage, max_weight_lifted, best_e1rm, sessions_count
                        FROM tracker_strength_summary_daily 
                        WHERE user_id = %s 
                        ORDER BY date DESC 
                        LIMIT 30
                    """, [user.id])
                    strength_data = cursor.fetchall()
                    
                    # Get cardio load from materialized view
                    cursor.execute("""
                        SELECT date, total_trimp, avg_hr, max_hr, sessions_count
                        FROM tracker_cardio_load_daily 
                        WHERE user_id = %s 
                        ORDER BY date DESC 
                        LIMIT 30
                    """, [user.id])
                    cardio_data = cursor.fetchall()
                    
            except Exception:
                # Fallback to ORM if materialized views don't exist or fail
                current_weight = None
                weight_change = None
                body_fat = None
                strength_data = []
                cardio_data = []
        
        # If materialized view failed, use ORM fallback
        if not strength_data:
            # Gather sessions and related strength sets
            sessions = (
                WorkoutSession.objects
                .filter(user=user)
                .prefetch_related('strength_sets')
                .order_by('-start_time')
            )

            # Volume trend per day (sum of reps*weight)
            volume_by_date = {}
            recent_sessions_data = []
            session_dates = []
            for s in sessions:
                if not s.date:
                    continue
                date_key = s.date.isoformat() if hasattr(s.date, 'isoformat') else str(s.date)
                session_dates.append(s.date)
                total = 0
                set_count = 0
                for ss in getattr(s, 'strength_sets', []).all() if hasattr(s, 'strength_sets') else []:
                    reps = ss.reps or 0
                    weight = ss.weight_kg or 0
                    total += reps * weight
                    set_count += 1
                volume_by_date[date_key] = volume_by_date.get(date_key, 0) + total
                recent_sessions_data.append({
                    'date': date_key,
                    'sets': set_count,
                    'volume': total,
                })

            # Sort recent sessions desc and trim
            recent_sessions_data.sort(key=lambda x: x['date'], reverse=True)
            recent_sessions = recent_sessions_data[:10]

            volume_trend = [
                { 'date': d, 'volume': volume_by_date[d] }
                for d in sorted(volume_by_date.keys())
            ]

            # Personal records: max weight per exercise
            max_by_exercise = {}
            max_date_by_exercise = {}
            for s in sessions:
                for ss in getattr(s, 'strength_sets', []).all() if hasattr(s, 'strength_sets') else []:
                    ex_id = ss.exercise_id
                    weight = ss.weight_kg or 0
                    if ex_id not in max_by_exercise or weight > max_by_exercise[ex_id]:
                        max_by_exercise[ex_id] = weight
                        max_date_by_exercise[ex_id] = s.date

            # Resolve exercise names
            exercise_names = {}
            if max_by_exercise:
                for ex in ExerciseCatalog.objects.filter(id__in=max_by_exercise.keys()):
                    exercise_names[ex.id] = ex.name
            prs = []
            for ex_id, max_w in max_by_exercise.items():
                date_val = max_date_by_exercise.get(ex_id)
                date_str = date_val.isoformat() if hasattr(date_val, 'isoformat') else str(date_val)
                prs.append({ 'exercise_id': ex_id, 'exercise': exercise_names.get(ex_id, f'Exercise #{ex_id}'), 'max_weight': max_w, 'date': date_str })
            prs.sort(key=lambda x: x['max_weight'], reverse=True)
            prs = prs[:8]  # top 8

            # Sessions per ISO week (YYYY-Www)
            sessions_per_week = {}
            for s in sessions:
                if not s.date:
                    continue
                year, week, _ = s.date.isocalendar()
                key = f"{year}-W{str(week).zfill(2)}"
                sessions_per_week[key] = sessions_per_week.get(key, 0) + 1
            sessions_per_week_list = [ { 'week': k, 'count': sessions_per_week[k] } for k in sorted(sessions_per_week.keys()) ]

            # KPIs
            last7_vol = sum([v['volume'] for v in volume_trend[-7:]]) if volume_trend else 0
            sessions_this_week = sessions_per_week_list[-1]['count'] if sessions_per_week_list else 0

            # Streaks (by day)
            session_dates = sorted(set(session_dates))
            longest_streak = 0
            current_streak = 0
            prev = None
            for d in session_dates:
                if prev and (d - prev == datetime.timedelta(days=1)):
                    current_streak += 1
                else:
                    current_streak = 1
                longest_streak = max(longest_streak, current_streak)
                prev = d
            best_week = None
            if sessions_per_week_list:
                best_week = max(sessions_per_week_list, key=lambda x: x['count'])
        else:
            # Use materialized view data
            volume_trend = [
                {'date': str(row[0]), 'volume': float(row[1]) or 0}
                for row in strength_data
            ]
            recent_sessions = [
                {'date': str(row[0]), 'sets': int(row[4]) or 0, 'volume': float(row[1]) or 0}
                for row in strength_data[:10]
            ]
            prs = []  # TODO: Implement PR extraction from materialized view
            sessions_per_week_list = []  # TODO: Implement weekly aggregation
            last7_vol = sum([v['volume'] for v in volume_trend[-7:]]) if volume_trend else 0
            sessions_this_week = 0  # TODO: Calculate from materialized view
            current_streak = 0  # TODO: Calculate from materialized view
            longest_streak = 0  # TODO: Calculate from materialized view
            best_week = None  # TODO: Calculate from materialized view

        # Nutrition overlay per date (always use ORM for now)
        nutrition_by_date = []
        totals = {}
        for n in NutritionLog.objects.filter(user=user).only('date', 'calories', 'protein_g'):
            key = n.date.isoformat() if hasattr(n.date, 'isoformat') else str(n.date)
            entry = totals.get(key, {'calories': 0, 'protein': 0})
            entry['calories'] += getattr(n, 'calories', 0) or 0
            entry['protein'] += getattr(n, 'protein_g', 0) or 0
            totals[key] = entry
        for k in sorted(totals.keys()):
            nutrition_by_date.append({ 'date': k, 'calories': totals[k]['calories'], 'protein': totals[k]['protein'] })

        # Fallback for current weight if materialized view didn't provide it
        if current_weight is None:
            try:
                latest_measure = BodyMeasurement.objects.filter(user=user).order_by('-date').first()
                if latest_measure and getattr(latest_measure, 'weight_kg', None) is not None:
                    current_weight = float(latest_measure.weight_kg)
            except Exception:
                pass

        # Today's calories from NutritionLog
        try:
            today = datetime.date.today()
            calories_today = (
                NutritionLog.objects.filter(user=user, date=today)
                .aggregate(total=models.Sum('calories'))
                .get('total') or 0
            )
        except Exception:
            calories_today = 0

        # Generate ETag for caching
        etag_data = f"{user.id}:{current_weight}:{calories_today}:{len(volume_trend)}"
        etag = hashlib.md5(etag_data.encode()).hexdigest()

        response = Response({
            'volume_trend': volume_trend,
            'prs': prs,
            'sessions_per_week': sessions_per_week_list,
            'recent_sessions': recent_sessions,
            'nutrition_by_date': nutrition_by_date,
            # Root-level mirrors for simpler frontend consumption
            'sessions_this_week': sessions_this_week,
            'calories_today': calories_today,
            'current_weight': current_weight,
            'weight_change': weight_change,
            'body_fat_percentage': body_fat,
            'kpis': {
                'total_volume_7d': last7_vol,
                'sessions_this_week': sessions_this_week,
                'current_streak': current_streak,
                'longest_streak': longest_streak,
                'best_week': best_week,
            }
        })
        
        # Add caching headers
        response['ETag'] = f'"{etag}"'
        response['Cache-Control'] = 'public, max-age=300'  # 5 minutes
        
        return response

class ProgressExerciseTrendView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, *args, **kwargs):
        user = request.user
        ex_id = request.query_params.get('exercise_id')
        if not ex_id:
            return Response({ 'detail': 'exercise_id is required' }, status=400)
        
        # Try to use materialized view first, fallback to ORM
        if not settings.MAR_FLAGS.get("aggregates_enabled", True):
            # Force legacy ORM path for backward compatibility
            strength_data = []
        else:
            try:
                with connection.cursor() as cursor:
                    # Get exercise trend from materialized view
                    cursor.execute("""
                        SELECT date, best_e1rm, max_weight_lifted
                        FROM tracker_strength_summary_daily 
                        WHERE user_id = %s 
                        ORDER BY date ASC
                    """, [user.id])
                    strength_data = cursor.fetchall()
                    
                    if strength_data:
                        # Use materialized view data
                        series = []
                        for row in strength_data:
                            date_str = str(row[0])
                            best_e1rm = float(row[1]) if row[1] else 0
                            max_weight = float(row[2]) if row[2] else 0
                            series.append({
                                'date': date_str,
                                'max_weight': max_weight,
                                'est_1rm': best_e1rm
                            })
                    else:
                        raise Exception("No data in materialized view")
                        
            except Exception:
                # Fallback to ORM if materialized views don't exist or fail
                strength_data = []
        
        # If materialized view failed, use ORM fallback
        if not strength_data:
            trend = {}
            for s in WorkoutSession.objects.filter(user=user).prefetch_related('strength_sets').order_by('start_time'):
                date_key = s.start_time.isoformat() if hasattr(s.start_time, 'isoformat') else str(s.start_time)
                for ss in getattr(s, 'strength_sets', []).all() if hasattr(s, 'strength_sets') else []:
                    if str(ss.exercise_id) != str(ex_id):
                        continue
                    w = ss.weight_kg or 0
                    r = ss.reps or 0
                    est_1rm = w * (1 + r/30.0)
                    if date_key not in trend or w > trend[date_key]['max_weight']:
                        trend[date_key] = { 'date': date_key, 'max_weight': w, 'est_1rm': est_1rm }
            series = [trend[k] for k in sorted(trend.keys())]
        else:
            # Use materialized view data
            series = []
            for row in strength_data:
                date_str = str(row[0])
                best_e1rm = float(row[1]) if row[1] else 0
                max_weight = float(row[2]) if row[2] else 0
                series.append({
                    'date': date_str,
                    'max_weight': max_weight,
                    'est_1rm': best_e1rm
                })

        # Generate ETag for caching
        etag_data = f"{user.id}:{ex_id}:{len(series)}"
        etag = hashlib.md5(etag_data.encode()).hexdigest()

        response = Response({ 'trend': series })
        response['ETag'] = f'"{etag}"'
        response['Cache-Control'] = 'public, max-age=300'  # 5 minutes
        
        return response

# A base viewset that automatically associates the user with the object
class BaseUserViewSet(viewsets.ModelViewSet):
    permission_classes = [permissions.IsAuthenticated, IsOwner]

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)
    
    def get_queryset(self):
        return self.queryset.filter(user=self.request.user)

class WorkoutSessionViewSet(BaseUserViewSet):
    queryset = WorkoutSession.objects.all()
    serializer_class = WorkoutSessionSerializer
    filter_backends = [filters.SearchFilter, filters.OrderingFilter]
    ordering_fields = ['start_time', 'end_time']
    
    def perform_create(self, serializer):
        """Auto-set user and start_time when creating a session"""
        serializer.save(
            user=self.request.user,
            start_time=timezone.now()
        )
    
    @action(detail=False, methods=['get'])
    def active(self, request):
        """Get currently active session (end_time is null)"""
        session = WorkoutSession.objects.filter(
            user=request.user,
            end_time__isnull=True
        ).first()
        
        if session:
            serializer = self.get_serializer(session)
            return Response(serializer.data)
        
        return Response({'active': False}, status=200)
    
    @action(detail=True, methods=['post'])
    def complete(self, request, pk=None):
        """End a workout session"""
        session = self.get_object()
        
        if session.end_time:
            return Response(
                {'error': 'Session already completed'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        session.end_time = timezone.now()
        session.save()
        
        serializer = self.get_serializer(session)
        return Response(serializer.data)

class UserProfileViewSet(viewsets.ModelViewSet):
    """
    API endpoint for viewing and editing the user's profile and preferences.
    """
    serializer_class = UserProfileSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        """
        This view should return a list of all the purchases
        for the currently authenticated user.
        """
        return UserProfile.objects.filter(user=self.request.user)

    def get_object(self):
        """
        Retrieve and return the profile for the authenticated user.
        Creates a profile if one doesn't exist.
        """
        obj, created = UserProfile.objects.get_or_create(user=self.request.user)
        return obj

    def list(self, request, *args, **kwargs):
        """
        Handle GET requests for the user's profile, returning a single object.
        """
        instance = self.get_object()
        serializer = self.get_serializer(instance)
        return Response(serializer.data)

class NutritionLogViewSet(BaseUserViewSet):
    queryset = NutritionLog.objects.all()
    serializer_class = NutritionLogSerializer

class MeasurementViewSet(BaseUserViewSet):
    queryset = BodyMeasurement.objects.all()
    serializer_class = BodyMeasurementSerializer

class GoalViewSet(BaseUserViewSet):
    queryset = Goal.objects.all()
    serializer_class = GoalSerializer

    def list(self, request, *args, **kwargs):
        # Include a computed progress field per goal
        response = super().list(request, *args, **kwargs)
        items = response.data
        try:
            # Resolve exercise names
            exercise_ids = [g['exercise'] for g in items if g.get('exercise')]
            ex_names = { ex.id: ex.name for ex in ExerciseCatalog.objects.filter(id__in=exercise_ids) }
            # Compute progress
            for g in items:
                metric = g.get('metric')
                target = float(g.get('target_value') or 0)
                progress = None
                if metric == 'weight_kg':
                    latest = BodyMeasurement.objects.filter(user=request.user).order_by('-date').first()
                    if latest and latest.weight_kg is not None:
                        progress = latest.weight_kg
                elif metric == 'body_fat':
                    latest = BodyMeasurement.objects.filter(user=request.user).order_by('-date').first()
                    if latest and latest.body_fat_percentage is not None:
                        progress = latest.body_fat_percentage
                elif metric == 'lift_kg':
                    ex_id = g.get('exercise')
                    if ex_id:
                        g['exercise_name'] = ex_names.get(ex_id)
                        best = 0
                        for s in WorkoutSession.objects.filter(user=request.user).prefetch_related('strength_sets'):
                            for ss in s.strength_sets.all():
                                if ss.exercise_id == ex_id and (ss.weight_kg or 0) > best:
                                    best = ss.weight_kg or 0
                        progress = best
                g['current_value'] = progress
                # ETA calculation
                if progress is not None and target:
                    g['percent'] = round(min(100.0, (progress / target) * 100.0), 1) if target > 0 else None
                    if metric in ('weight_kg', 'body_fat'):
                        field = 'weight_kg' if metric == 'weight_kg' else 'body_fat_percentage'
                        # Look at last 30 days
                        cutoff = datetime.date.today() - datetime.timedelta(days=30)
                        recent = (
                            BodyMeasurement.objects
                            .filter(user=request.user, date__gte=cutoff)
                            .order_by('date')
                            .values('date', val=F(field))
                        )
                        if len(recent) > 1:
                            start_val = recent[0]['val']
                            end_val = recent[len(recent)-1]['val']
                            if start_val is not None and end_val is not None:
                                days = (recent[len(recent)-1]['date'] - recent[0]['date']).days
                                if days > 0:
                                    rate = (end_val - start_val) / days
                                    remaining = target - end_val
                                    if (rate > 0 and remaining > 0) or (rate < 0 and remaining < 0):
                                        eta_days = abs(remaining / rate)
                                        eta_date = datetime.date.today() + datetime.timedelta(days=eta_days)
                                        g['eta'] = eta_date.isoformat()
        except Exception:
            pass
        return response

# Viewsets that are not user-specific or are read-only for all authenticated users
class ExerciseCatalogViewSet(viewsets.ReadOnlyModelViewSet):
    """This viewset provides a read-only list of all available exercises."""
    queryset = ExerciseCatalog.objects.all().prefetch_related('equipments', 'muscles').distinct()
    serializer_class = ExerciseCatalogSerializer
    permission_classes = [permissions.AllowAny]
    filterset_class = ExerciseFilter
    search_fields = ['name', 'description']
    ordering_fields = ['name', 'difficulty_level']

    def list(self, request, *args, **kwargs):
        # Apply filters/search/order via DRF machinery
        queryset = self.filter_queryset(self.get_queryset())

        # Compute facets on the filtered (but unpaginated) queryset
        equipment_counts_qs = queryset.values('equipments__name').annotate(count=Count('id')).order_by('-count')
        muscle_counts_qs = queryset.values('muscles__name').annotate(count=Count('id')).order_by('-count')
        equipment_counts = [
            { 'name': row['equipments__name'] or 'Unspecified', 'count': row['count'] }
            for row in equipment_counts_qs
            if row['equipments__name'] is not None
        ]
        muscle_counts = [
            { 'name': row['muscles__name'] or 'Unspecified', 'count': row['count'] }
            for row in muscle_counts_qs
            if row['muscles__name'] is not None
        ]

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            response = self.get_paginated_response(serializer.data)
            # Inject facets into paginated envelope
            response.data['facets'] = {
                'equipments': equipment_counts,
                'muscles': muscle_counts,
            }
            return response

        serializer = self.get_serializer(queryset, many=True)
        # Non-paginated fallback shape mirrors paginated 'results'
        return Response({
            'count': len(serializer.data),
            'next': None,
            'previous': None,
            'results': serializer.data,
            'facets': {
                'equipments': equipment_counts,
                'muscles': muscle_counts,
            }
        })


class MuscleViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Muscle.objects.all()
    serializer_class = MuscleSerializer
    permission_classes = [permissions.AllowAny]

class EquipmentViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Equipment.objects.all()
    serializer_class = EquipmentSerializer
    permission_classes = [permissions.AllowAny]

class TagViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Tag.objects.all()
    serializer_class = TagSerializer
    permission_classes = [permissions.AllowAny]

class FoodCatalogViewSet(viewsets.ReadOnlyModelViewSet):
    """Read-only list/search of foods with nutrition per 100g."""
    queryset = FoodCatalog.objects.all()
    serializer_class = FoodCatalogSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        qs = super().get_queryset()
        q = self.request.query_params.get('q')
        if q:
            qs = qs.filter(name__icontains=q)
        return qs

# These viewsets are for nested objects and are more tightly controlled
# For simplicity, StrengthSet and CardioEntry are created/managed via WorkoutSession
# If direct access is needed, they would look like this:
class StrengthSetViewSet(viewsets.ModelViewSet):
    serializer_class = StrengthSetSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return StrengthSet.objects.filter(session__user=self.request.user)

class CardioEntryViewSet(viewsets.ModelViewSet):
    serializer_class = CardioEntrySerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return CardioEntry.objects.filter(session__user=self.request.user)

# Calculator Views
class CalculatorView(APIView):
    """Calculate BMI, BMR, TDEE, and macro targets."""
    permission_classes = [permissions.AllowAny]  # Temporarily allow unauthenticated access for testing
    
    def post(self, request):
        from .calculators import FitnessCalculator
        
        goal_type = request.data.get('goal', 'maintenance')
        
        # If user is authenticated, use their data
        if request.user.is_authenticated:
            calculation_result = FitnessCalculator.calculate_all(request.user, goal_type)
        else:
            # For unauthenticated users, use data from request body
            try:
                weight = float(request.data.get('weight'))
                height = float(request.data.get('height'))
                age = int(request.data.get('age'))
                gender = request.data.get('gender', 'male')
                activity = request.data.get('activity_level', 'moderate')

                if not all([weight, height, age, gender, activity]):
                    return Response({'error': 'Missing required fields for calculation.'}, status=400)

                calculation_result = self._get_anonymous_calculation(
                    weight, height, age, gender, activity, goal_type
                )
            except (ValueError, TypeError):
                return Response({'error': 'Invalid input data format.'}, status=400)

        if 'error' in calculation_result:
            return Response(calculation_result, status=400)
        
        return Response(calculation_result)
    
    def _get_anonymous_calculation(self, weight_kg, height_cm, age, gender, activity_level, goal_type):
        """Provide calculation for anonymous users based on POST data."""
        from .calculators import FitnessCalculator
        
        # Calculate all metrics
        bmi_result = FitnessCalculator.calculate_bmi(weight_kg, height_cm)
        bmr_result = FitnessCalculator.calculate_bmr(weight_kg, height_cm, age, gender)
        
        if 'error' in bmr_result:
            return bmr_result

        tdee_result = FitnessCalculator.calculate_tdee(bmr_result['bmr'], activity_level)

        if 'error' in tdee_result:
            return tdee_result
            
        macro_result = FitnessCalculator.calculate_macro_targets(
            tdee_result['tdee'], goal_type, weight_kg, activity_level
        )
        
        return {
            'bmi': bmi_result,
            'bmr': bmr_result,
            'tdee': tdee_result,
            'macros': macro_result,
            'calculated_at': '2024-01-01', # Placeholder
            'sample_data': False,
            'message': 'Calculation based on provided data.'
        }

class MacroTargetViewSet(viewsets.ModelViewSet):
    """Manage daily macro targets."""
    serializer_class = MacroTargetSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return MacroTarget.objects.filter(user=self.request.user)
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

class CalculatorResultViewSet(viewsets.ReadOnlyModelViewSet):
    """View calculation history."""
    serializer_class = CalculatorResultSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return CalculatorResult.objects.filter(user=self.request.user)

# Smart Recommendations Views
class RecommendationsView(APIView):
    """Get AI-powered recommendations for workouts, nutrition, and progress."""
    permission_classes = [permissions.AllowAny]  # Temporarily allow unauthenticated access for testing
    
    def get(self, request):
        from .recommendations import SmartRecommendations
        
        recommendation_type = request.query_params.get('type', 'all')
        
        try:
            # For testing without authentication, use a sample user or return sample data
            if not request.user.is_authenticated:
                # Return sample recommendations for unauthenticated users
                from .recommendations import SmartRecommendations
                sample_recommender = SmartRecommendations(None)
                recommendations = sample_recommender._get_sample_recommendations()
                return Response(recommendations)
            
            recommender = SmartRecommendations(request.user)
            
            if recommendation_type == 'workout':
                recommendations = recommender.get_workout_recommendations()
            elif recommendation_type == 'nutrition':
                recommendations = recommender.get_nutrition_recommendations()
            elif recommendation_type == 'progress':
                recommendations = recommender.get_progress_recommendations()
            else:
                recommendations = recommender.get_comprehensive_recommendations()
            
            return Response(recommendations)
            
        except Exception as e:
            return Response({'error': f'Failed to generate recommendations: {str(e)}'}, status=500)

# Advanced Analytics Views
class AnalyticsView(APIView):
    """Get comprehensive analytics for the user."""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        from .analytics import AdvancedAnalytics
        
        analytics_type = request.query_params.get('type', 'daily')
        days = int(request.query_params.get('days', 30))
        
        try:
            analytics_engine = AdvancedAnalytics(request.user)
            
            if analytics_type == 'daily':
                target_date = request.query_params.get('date')
                if target_date:
                    target_date = datetime.strptime(target_date, '%Y-%m-%d').date()
                else:
                    target_date = None
                
                analytics = analytics_engine.compute_daily_analytics(target_date)
            elif analytics_type == 'trends':
                analytics = analytics_engine.get_trend_analysis(days)
            elif analytics_type == 'streak':
                analytics = analytics_engine.update_workout_streak()
            elif analytics_type == 'records':
                analytics = analytics_engine.get_personal_records_summary()
            elif analytics_type == 'achievements':
                analytics = analytics_engine.get_achievements_summary()
            else:
                return Response({'error': 'Invalid analytics type'}, status=400)
            
            return Response(analytics)
            
        except Exception as e:
            return Response({'error': f'Failed to compute analytics: {str(e)}'}, status=500)

# Social Features Views
class SocialView(APIView):
    """Social features API."""
    permission_classes = [permissions.AllowAny]  # Temporarily allow unauthenticated access for testing
    
    def get(self, request):
        from .social import SocialFeatures
        
        feature = request.query_params.get('feature', 'friends')
        
        try:
            # If user is authenticated, use their data
            if request.user.is_authenticated:
                social_engine = SocialFeatures(request.user)
                
                if feature == 'friends':
                    result = social_engine.get_friends()
                elif feature == 'challenges':
                    result = social_engine.get_available_challenges()
                elif feature == 'my_challenges':
                    result = social_engine.get_my_challenges()
                elif feature == 'leaderboards':
                    result = social_engine.get_available_leaderboards()
                elif feature == 'achievements':
                    result = social_engine.get_user_achievements()
                elif feature == 'community_stats':
                    result = social_engine.get_community_stats()
                else:
                    return Response({'error': 'Invalid feature'}, status=400)
            else:
                # For unauthenticated users, provide sample data
                result = self._get_sample_social_data(feature)
            
            return Response(result)
            
        except Exception as e:
            return Response({'error': f'Failed to get social data: {str(e)}'}, status=500)
    
    def _get_sample_social_data(self, feature):
        """Provide sample social data for unauthenticated users."""
        if feature == 'friends':
            return {
                'friends': [
                    {
                        'id': 1,
                        'username': 'FitnessBuddy',
                        'display_name': 'Alex Johnson',
                        'avatar': '/images/default-avatar.png',
                        'status': 'active',
                        'last_workout': '2 hours ago',
                        'current_streak': 7,
                        'total_workouts': 45
                    },
                    {
                        'id': 2,
                        'username': 'GymWarrior',
                        'display_name': 'Sarah Chen',
                        'avatar': '/images/default-avatar.png',
                        'status': 'active',
                        'last_workout': '1 day ago',
                        'current_streak': 3,
                        'total_workouts': 32
                    }
                ],
                'pending_requests': [],
                'sample_data': True,
                'message': 'This is sample data. Please log in to see your actual friends.'
            }
        elif feature == 'challenges':
            return {
                'available_challenges': [
                    {
                        'id': 1,
                        'name': '30-Day Fitness Challenge',
                        'description': 'Complete 30 workouts in 30 days',
                        'type': 'workout_count',
                        'target': 30,
                        'duration_days': 30,
                        'participants': 156,
                        'start_date': '2024-01-01',
                        'end_date': '2024-01-31',
                        'difficulty': 'intermediate'
                    },
                    {
                        'id': 2,
                        'name': 'Cardio Blast',
                        'description': 'Complete 10 hours of cardio this month',
                        'type': 'cardio_hours',
                        'target': 10,
                        'duration_days': 30,
                        'participants': 89,
                        'start_date': '2024-01-01',
                        'end_date': '2024-01-31',
                        'difficulty': 'advanced'
                    }
                ],
                'sample_data': True,
                'message': 'This is sample data. Please log in to join real challenges.'
            }
        elif feature == 'leaderboards':
            return {
                'available_leaderboards': [
                    {
                        'id': 1,
                        'name': 'Monthly Workout Count',
                        'description': 'Most workouts completed this month',
                        'metric': 'workout_count',
                        'period': 'monthly',
                        'participants': 234,
                        'top_entries': [
                            {'rank': 1, 'username': 'FitnessKing', 'value': 28, 'avatar': '/images/default-avatar.png'},
                            {'rank': 2, 'username': 'GymBeast', 'value': 26, 'avatar': '/images/default-avatar.png'},
                            {'rank': 3, 'username': 'WorkoutWarrior', 'value': 24, 'avatar': '/images/default-avatar.png'}
                        ]
                    }
                ],
                'sample_data': True,
                'message': 'This is sample data. Please log in to see real leaderboards.'
            }
        elif feature == 'achievements':
            return {
                'user_achievements': [
                    {
                        'id': 1,
                        'name': 'First Workout',
                        'description': 'Complete your first workout',
                        'icon': 'ðŸ‹ï¸',
                        'earned_date': '2024-01-01',
                        'rarity': 'common'
                    },
                    {
                        'id': 2,
                        'name': 'Week Warrior',
                        'description': 'Complete 7 workouts in a week',
                        'icon': 'ðŸ”¥',
                        'earned_date': '2024-01-15',
                        'rarity': 'uncommon'
                    }
                ],
                'available_achievements': [
                    {
                        'id': 3,
                        'name': 'Month Master',
                        'description': 'Complete 20 workouts in a month',
                        'icon': 'ðŸ’ª',
                        'progress': 0.6,
                        'rarity': 'rare'
                    }
                ],
                'sample_data': True,
                'message': 'This is sample data. Please log in to see your actual achievements.'
            }
        else:
            return {'error': 'Invalid feature'}
    
    def post(self, request):
        from .social import SocialFeatures
        
        action = request.data.get('action')
        
        try:
            social_engine = SocialFeatures(request.user)
            
            if action == 'send_friend_request':
                target_user_id = request.data.get('target_user_id')
                connection_type = request.data.get('connection_type', 'friend')
                
                try:
                    target_user = User.objects.get(id=target_user_id)
                    result = social_engine.send_friend_request(target_user, connection_type)
                except User.DoesNotExist:
                    return Response({'error': 'User not found'}, status=404)
            
            elif action == 'accept_friend_request':
                connection_id = request.data.get('connection_id')
                result = social_engine.accept_friend_request(connection_id)
            
            elif action == 'join_challenge':
                challenge_id = request.data.get('challenge_id')
                result = social_engine.join_challenge(challenge_id)
            
            elif action == 'create_challenge':
                challenge_data = request.data.get('challenge_data')
                result = social_engine.create_challenge(challenge_data)
            
            elif action == 'update_challenge_progress':
                challenge_id = request.data.get('challenge_id')
                result = social_engine.update_challenge_progress(challenge_id)
            
            else:
                return Response({'error': 'Invalid action'}, status=400)
            
            return Response(result)
            
        except Exception as e:
            return Response({'error': f'Failed to perform social action: {str(e)}'}, status=500)

class LeaderboardView(APIView):
    """Leaderboard API."""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, leaderboard_id):
        from .social import SocialFeatures
        
        try:
            social_engine = SocialFeatures(request.user)
            result = social_engine.get_leaderboard(leaderboard_id)
            return Response(result)
            
        except Exception as e:
            return Response({'error': f'Failed to get leaderboard: {str(e)}'}, status=500)
    
    def post(self, request, leaderboard_id):
        from .social import SocialFeatures
        
        action = request.data.get('action')
        
        try:
            social_engine = SocialFeatures(request.user)
            
            if action == 'update':
                result = social_engine.update_leaderboard(leaderboard_id)
            else:
                return Response({'error': 'Invalid action'}, status=400)
            
            return Response(result)
            
        except Exception as e:
            return Response({'error': f'Failed to update leaderboard: {str(e)}'}, status=500)

class FriendActivityView(APIView):
    """Friend activity API."""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, friend_id):
        from .social import SocialFeatures
        
        days = int(request.query_params.get('days', 7))
        
        try:
            social_engine = SocialFeatures(request.user)
            result = social_engine.get_friend_activity(friend_id, days)
            return Response(result)
            
        except Exception as e:
            return Response({'error': f'Failed to get friend activity: {str(e)}'}, status=500)


# Photo Progress Viewsets
class ProgressPhotoViewSet(viewsets.ModelViewSet):
    """ViewSet for managing progress photos."""
    serializer_class = ProgressPhotoSerializer
    permission_classes = [permissions.AllowAny]  # Temporarily allow unauthenticated access for testing
    
    def get_queryset(self):
        if self.request.user.is_authenticated:
            return ProgressPhoto.objects.filter(user=self.request.user)
        else:
            # Return sample photos for unauthenticated users
            return ProgressPhoto.objects.none()
    
    def perform_create(self, serializer):
        if self.request.user.is_authenticated:
            serializer.save(user=self.request.user)
        else:
            # For demo purposes, create sample data
            pass


class PhotoComparisonViewSet(viewsets.ModelViewSet):
    """ViewSet for managing photo comparisons."""
    serializer_class = PhotoComparisonSerializer
    permission_classes = [permissions.AllowAny]  # Temporarily allow unauthenticated access for testing
    
    def get_queryset(self):
        if self.request.user.is_authenticated:
            return PhotoComparison.objects.filter(user=self.request.user)
        else:
            # Return sample comparisons for unauthenticated users
            return PhotoComparison.objects.none()
    
    def perform_create(self, serializer):
        if self.request.user.is_authenticated:
            serializer.save(user=self.request.user)
        else:
            # For demo purposes, create sample data
            pass


class BodyPartMeasurementViewSet(viewsets.ModelViewSet):
    """ViewSet for managing body part measurements."""
    serializer_class = BodyPartMeasurementSerializer
    permission_classes = [permissions.AllowAny]  # Temporarily allow unauthenticated access for testing
    
    def get_queryset(self):
        if self.request.user.is_authenticated:
            return BodyPartMeasurement.objects.filter(user=self.request.user)
        else:
            # Return sample measurements for unauthenticated users
            return BodyPartMeasurement.objects.none()
    
    def perform_create(self, serializer):
        if self.request.user.is_authenticated:
            serializer.save(user=self.request.user)
        else:
            # For demo purposes, create sample data
            pass


class ProgressMilestoneViewSet(viewsets.ModelViewSet):
    """ViewSet for managing progress milestones."""
    serializer_class = ProgressMilestoneSerializer
    permission_classes = [permissions.AllowAny]  # Temporarily allow unauthenticated access for testing
    
    def get_queryset(self):
        if self.request.user.is_authenticated:
            return ProgressMilestone.objects.filter(user=self.request.user)
        else:
            # Return sample milestones for unauthenticated users
            return ProgressMilestone.objects.none()
    
    def perform_create(self, serializer):
        if self.request.user.is_authenticated:
            serializer.save(user=self.request.user)
        else:
            # For demo purposes, create sample data
            pass


class PhotoProgressAPIView(APIView):
    """Comprehensive photo progress API with sample data for unauthenticated users."""
    permission_classes = [permissions.AllowAny]  # Temporarily allow unauthenticated access for testing
    
    def get(self, request):
        """Get comprehensive photo progress data."""
        if request.user.is_authenticated:
            # Return real user data
            photos = ProgressPhoto.objects.filter(user=request.user).order_by('-date_taken')
            comparisons = PhotoComparison.objects.filter(user=request.user).order_by('-created_at')
            measurements = BodyPartMeasurement.objects.filter(user=request.user).order_by('-measurement_date')
            milestones = ProgressMilestone.objects.filter(user=request.user).order_by('-achievement_date')
            
            return Response({
                'photos': ProgressPhotoSerializer(photos, many=True, context={'request': request}).data,
                'comparisons': PhotoComparisonSerializer(comparisons, many=True, context={'request': request}).data,
                'measurements': BodyPartMeasurementSerializer(measurements, many=True, context={'request': request}).data,
                'milestones': ProgressMilestoneSerializer(milestones, many=True, context={'request': request}).data,
                'is_authenticated': True
            })
        else:
            # Return sample data for unauthenticated users
            return Response({
                'photos': [
                    {
                        'id': 1,
                        'photo_type': 'front',
                        'image_url': '/images/sample-progress-photo-1.jpg',
                        'thumbnail_url': '/images/sample-progress-thumbnail-1.jpg',
                        'date_taken': '2024-01-01T00:00:00Z',
                        'weight_at_time': 70.0,
                        'body_fat_at_time': 15.0,
                        'notes': 'Starting my fitness journey!',
                        'is_public': False,
                        'allow_comparisons': True
                    },
                    {
                        'id': 2,
                        'photo_type': 'front',
                        'image_url': '/images/sample-progress-photo-2.jpg',
                        'thumbnail_url': '/images/sample-progress-thumbnail-2.jpg',
                        'date_taken': '2024-02-01T00:00:00Z',
                        'weight_at_time': 68.0,
                        'body_fat_at_time': 13.0,
                        'notes': 'One month progress - feeling stronger!',
                        'is_public': False,
                        'allow_comparisons': True
                    }
                ],
                'comparisons': [
                    {
                        'id': 1,
                        'title': 'My Transformation',
                        'description': 'Amazing progress in just 30 days!',
                        'comparison_type': 'before_after',
                        'time_difference_days': 30,
                        'weight_change': -2.0,
                        'body_fat_change': -2.0,
                        'before_photo_data': {
                            'id': 1,
                            'photo_type': 'front',
                            'image_url': '/images/sample-progress-photo-1.jpg',
                            'date_taken': '2024-01-01T00:00:00Z'
                        },
                        'after_photo_data': {
                            'id': 2,
                            'photo_type': 'front',
                            'image_url': '/images/sample-progress-photo-2.jpg',
                            'date_taken': '2024-02-01T00:00:00Z'
                        },
                        'is_public': False,
                        'is_featured': True
                    }
                ],
                'measurements': [
                    {
                        'id': 1,
                        'body_part': 'chest',
                        'measurement_cm': 95.0,
                        'measurement_inches': 37.4,
                        'is_flexed': False,
                        'is_relaxed': True,
                        'measurement_date': '2024-01-01T00:00:00Z',
                        'notes': 'Starting chest measurement'
                    },
                    {
                        'id': 2,
                        'body_part': 'chest',
                        'measurement_cm': 98.0,
                        'measurement_inches': 38.6,
                        'is_flexed': False,
                        'is_relaxed': True,
                        'measurement_date': '2024-02-01T00:00:00Z',
                        'notes': 'Chest growth after 1 month'
                    }
                ],
                'milestones': [
                    {
                        'id': 1,
                        'milestone_type': 'weight_loss',
                        'title': 'First 2kg Lost!',
                        'description': 'Successfully lost 2kg in my first month',
                        'target_value': 2.0,
                        'achieved_value': 2.0,
                        'achievement_date': '2024-02-01T00:00:00Z',
                        'is_celebrated': True,
                        'celebration_notes': 'So proud of this achievement!'
                    }
                ],
                'is_authenticated': False,
                'sample_data': True,
                'message': 'This is sample data. Please log in to track your actual progress photos.'
            })


# Advanced Analytics Viewsets
class MuscleGroupViewSet(viewsets.ReadOnlyModelViewSet):
    """ViewSet for muscle groups (read-only)."""
    serializer_class = MuscleGroupSerializer
    permission_classes = [permissions.AllowAny]
    
    def get_queryset(self):
        return MuscleGroup.objects.all()


class BodyCompositionViewSet(viewsets.ModelViewSet):
    """ViewSet for body composition tracking."""
    serializer_class = BodyCompositionSerializer
    permission_classes = [permissions.AllowAny]  # Temporarily allow unauthenticated access for testing
    
    def get_queryset(self):
        if self.request.user.is_authenticated:
            return BodyComposition.objects.filter(user=self.request.user)
        else:
            return BodyComposition.objects.none()
    
    def perform_create(self, serializer):
        if self.request.user.is_authenticated:
            serializer.save(user=self.request.user)


class MuscleGroupMeasurementViewSet(viewsets.ModelViewSet):
    """ViewSet for muscle group measurements."""
    serializer_class = MuscleGroupMeasurementSerializer
    permission_classes = [permissions.AllowAny]  # Temporarily allow unauthenticated access for testing
    
    def get_queryset(self):
        if self.request.user.is_authenticated:
            return MuscleGroupMeasurement.objects.filter(user=self.request.user)
        else:
            return MuscleGroupMeasurement.objects.none()
    
    def perform_create(self, serializer):
        if self.request.user.is_authenticated:
            serializer.save(user=self.request.user)


class BodyAnalyticsViewSet(viewsets.ReadOnlyModelViewSet):
    """ViewSet for body analytics (read-only)."""
    serializer_class = BodyAnalyticsSerializer
    permission_classes = [permissions.AllowAny]  # Temporarily allow unauthenticated access for testing
    
    def get_queryset(self):
        if self.request.user.is_authenticated:
            return BodyAnalytics.objects.filter(user=self.request.user)
        else:
            return BodyAnalytics.objects.none()


class ProgressPredictionViewSet(viewsets.ReadOnlyModelViewSet):
    """ViewSet for progress predictions (read-only)."""
    serializer_class = ProgressPredictionSerializer
    permission_classes = [permissions.AllowAny]  # Temporarily allow unauthenticated access for testing
    
    def get_queryset(self):
        if self.request.user.is_authenticated:
            return ProgressPrediction.objects.filter(user=self.request.user)
        else:
            return ProgressPrediction.objects.none()


class AdvancedAnalyticsAPIView(APIView):
    """Comprehensive advanced analytics API."""
    permission_classes = [permissions.AllowAny]  # Temporarily allow unauthenticated access for testing
    
    def get(self, request):
        """Get comprehensive advanced analytics data."""
        if request.user.is_authenticated:
            from .analytics_engine import AdvancedAnalyticsEngine
            
            analytics_engine = AdvancedAnalyticsEngine(request.user)
            
            # Get analytics data
            body_composition_analysis = analytics_engine.analyze_body_composition_trends()
            muscle_growth_analysis = analytics_engine.analyze_muscle_group_growth()
            progress_predictions = analytics_engine.generate_progress_predictions()
            symmetry_analysis = analytics_engine.calculate_body_symmetry_score()
            
            return Response({
                'body_composition': body_composition_analysis,
                'muscle_growth': muscle_growth_analysis,
                'predictions': progress_predictions,
                'symmetry': symmetry_analysis,
                'is_authenticated': True
            })
        else:
            # Return sample data for unauthenticated users
            return Response({
                'body_composition': {
                    'period_days': 30,
                    'data_points': 5,
                    'weight_trend': -0.1,
                    'body_fat_trend': -0.2,
                    'muscle_mass_trend': 0.05,
                    'weight_change_kg': -2.0,
                    'body_fat_change_percent': -1.5,
                    'muscle_mass_change_kg': 0.8,
                    'current_weight': 68.0,
                    'current_body_fat': 13.5,
                    'current_muscle_mass': 45.2,
                    'body_shape_type': 'mesomorph',
                    'metabolic_age': 25,
                    'bmr_calories': 1650,
                    'insights': [
                        "Excellent fat loss progress - body fat percentage decreasing",
                        "Muscle mass growing - strength training is working!",
                        "Significant weight loss detected - great progress!"
                    ]
                },
                'muscle_growth': {
                    'period_days': 30,
                    'muscle_groups': {
                        'chest': {
                            'display_name': 'Chest',
                            'current_size_cm': 95.5,
                            'growth_cm': 1.5,
                            'growth_percent': 1.6,
                            'measurements_count': 3,
                            'trend': 'growing',
                            'muscle_density': 'firm',
                            'is_flexed': False,
                            'workout_context': 'morning'
                        },
                        'biceps': {
                            'display_name': 'Biceps',
                            'current_size_cm': 35.2,
                            'growth_cm': 1.2,
                            'growth_percent': 3.5,
                            'measurements_count': 3,
                            'trend': 'growing',
                            'muscle_density': 'firm',
                            'is_flexed': False,
                            'workout_context': 'morning'
                        },
                        'quads': {
                            'display_name': 'Quadriceps',
                            'current_size_cm': 56.0,
                            'growth_cm': 1.0,
                            'growth_percent': 1.8,
                            'measurements_count': 2,
                            'trend': 'growing',
                            'muscle_density': 'hard',
                            'is_flexed': False,
                            'workout_context': 'morning'
                        }
                    },
                    'fastest_growing': 'biceps',
                    'slowest_growing': 'quads',
                    'total_muscle_groups_tracked': 3,
                    'average_growth_percent': 2.3,
                    'insights': [
                        "3 muscle groups showing growth - excellent progress!",
                        "Biceps showing exceptional growth!"
                    ]
                },
                'predictions': {
                    'prediction_horizon_days': 30,
                    'confidence_level': 0.85,
                    'current_values': {
                        'weight_kg': 68.0,
                        'body_fat_percent': 13.5,
                        'muscle_mass_kg': 45.2
                    },
                    'predicted_values': {
                        'weight_kg': 66.5,
                        'body_fat_percent': 12.0,
                        'muscle_mass_kg': 46.0
                    },
                    'muscle_predictions': {
                        'chest': {'current_cm': 95.5, 'predicted_cm': 97.0, 'growth_cm': 1.5, 'confidence': 0.85},
                        'biceps': {'current_cm': 35.2, 'predicted_cm': 36.4, 'growth_cm': 1.2, 'confidence': 0.85},
                        'quads': {'current_cm': 56.0, 'predicted_cm': 57.0, 'growth_cm': 1.0, 'confidence': 0.85}
                    },
                    'trends_analyzed': {
                        'weight_trend_per_day': -0.05,
                        'body_fat_trend_per_day': -0.05,
                        'muscle_mass_trend_per_day': 0.03
                    },
                    'data_points_used': 5,
                    'recommendations': [
                        "Continue current training program - excellent progress predicted",
                        "Maintain protein intake for muscle growth",
                        "Consider adding more volume to lagging muscle groups"
                    ]
                },
                'symmetry': {
                    'symmetry_score': 82.5,
                    'balance_score': 78.5,
                    'overall_score': 80.5,
                    'muscle_data': {
                        'chest': {'size_cm': 95.5, 'muscle_density': 'firm', 'is_flexed': False},
                        'biceps': {'size_cm': 35.2, 'muscle_density': 'firm', 'is_flexed': False},
                        'quads': {'size_cm': 56.0, 'muscle_density': 'hard', 'is_flexed': False}
                    },
                    'recommendations': [
                        "Focus on unilateral exercises to improve balance",
                        "Ensure equal training volume for opposing muscle groups",
                        "Consider adding corrective exercises for weaker areas"
                    ]
                },
                'is_authenticated': False,
                'sample_data': True,
                'message': 'This is sample data. Please log in to track your actual body analytics.'
            })


# ============================================================================
# ENHANCED NUTRITION SYSTEM VIEWSETS
# ============================================================================

class FoodCategoryViewSet(viewsets.ModelViewSet):
    """ViewSet for food categories."""
    queryset = FoodCategory.objects.all()
    serializer_class = FoodCategorySerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filter_backends = [filters.SearchFilter, filters.OrderingFilter]
    search_fields = ['name', 'description']
    ordering_fields = ['sort_order', 'name']
    ordering = ['sort_order', 'name']


class RecipeViewSet(viewsets.ModelViewSet):
    """ViewSet for recipes."""
    serializer_class = RecipeSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ['name', 'description', 'cuisine_type']
    ordering_fields = ['created_at', 'name', 'calories_per_serving']
    ordering = ['-created_at']
    filterset_fields = ['meal_type', 'difficulty', 'is_public', 'created_by']

    def get_queryset(self):
        """Return public recipes or user's own recipes."""
        if self.request.user.is_authenticated:
            return Recipe.objects.filter(
                models.Q(is_public=True) | models.Q(created_by=self.request.user)
            )
        return Recipe.objects.filter(is_public=True)

    def perform_create(self, serializer):
        """Set the creator to the current user."""
        serializer.save(created_by=self.request.user)


class RecipeIngredientViewSet(viewsets.ModelViewSet):
    """ViewSet for recipe ingredients."""
    queryset = RecipeIngredient.objects.all()
    serializer_class = RecipeIngredientSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['recipe']


class RecipeInstructionViewSet(viewsets.ModelViewSet):
    """ViewSet for recipe instructions."""
    queryset = RecipeInstruction.objects.all()
    serializer_class = RecipeInstructionSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['recipe']


class MealPlanViewSet(viewsets.ModelViewSet):
    """ViewSet for meal plans."""
    serializer_class = MealPlanSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ['name', 'description']
    ordering_fields = ['created_at', 'start_date', 'end_date']
    ordering = ['-created_at']
    filterset_fields = ['is_active']

    def get_queryset(self):
        """Return meal plans for the current user."""
        return MealPlan.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        """Set the user to the current user."""
        serializer.save(user=self.request.user)


class MealPlanDayViewSet(viewsets.ModelViewSet):
    """ViewSet for meal plan days."""
    serializer_class = MealPlanDaySerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [DjangoFilterBackend, filters.OrderingFilter]
    ordering_fields = ['date']
    ordering = ['date']
    filterset_fields = ['meal_plan', 'date']

    def get_queryset(self):
        """Return meal plan days for the current user's meal plans."""
        return MealPlanDay.objects.filter(meal_plan__user=self.request.user)


class MealPlanMealViewSet(viewsets.ModelViewSet):
    """ViewSet for meal plan meals."""
    serializer_class = MealPlanMealSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [DjangoFilterBackend, filters.OrderingFilter]
    ordering_fields = ['meal_time', 'meal_type']
    ordering = ['meal_time', 'meal_type']
    filterset_fields = ['meal_plan_day', 'meal_type']

    def get_queryset(self):
        """Return meals for the current user's meal plans."""
        return MealPlanMeal.objects.filter(meal_plan_day__meal_plan__user=self.request.user)


class MealTemplateViewSet(viewsets.ModelViewSet):
    """ViewSet for meal templates."""
    serializer_class = MealTemplateSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ['name', 'description']
    ordering_fields = ['created_at', 'name']
    ordering = ['-created_at']
    filterset_fields = ['meal_type', 'goal_type', 'is_public', 'created_by']

    def get_queryset(self):
        """Return public templates or user's own templates."""
        if self.request.user.is_authenticated:
            return MealTemplate.objects.filter(
                models.Q(is_public=True) | models.Q(created_by=self.request.user)
            )
        return MealTemplate.objects.filter(is_public=True)

    def perform_create(self, serializer):
        """Set the creator to the current user."""
        serializer.save(created_by=self.request.user)


class NutritionGoalViewSet(viewsets.ModelViewSet):
    """ViewSet for nutrition goals."""
    serializer_class = NutritionGoalSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
    ordering_fields = ['created_at', 'start_date']
    ordering = ['-created_at']
    filterset_fields = ['goal_type', 'is_active']

    def get_queryset(self):
        """Return nutrition goals for the current user."""
        return NutritionGoal.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        """Set the user to the current user."""
        serializer.save(user=self.request.user)


class WaterIntakeViewSet(viewsets.ModelViewSet):
    """ViewSet for water intake tracking."""
    serializer_class = WaterIntakeSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
    ordering_fields = ['date', 'timestamp']
    ordering = ['-date', '-timestamp']
    filterset_fields = ['date']

    def get_queryset(self):
        """Return water intake records for the current user."""
        return WaterIntake.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        """Set the user to the current user."""
        serializer.save(user=self.request.user)


class SupplementLogViewSet(viewsets.ModelViewSet):
    """ViewSet for supplement logging."""
    serializer_class = SupplementLogSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ['supplement_name']
    ordering_fields = ['date', 'time_taken']
    ordering = ['-date', '-time_taken']
    filterset_fields = ['date', 'supplement_name']

    def get_queryset(self):
        """Return supplement logs for the current user."""
        return SupplementLog.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        """Set the user to the current user."""
        serializer.save(user=self.request.user)


class MealRatingViewSet(viewsets.ModelViewSet):
    """ViewSet for meal ratings."""
    serializer_class = MealRatingSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
    ordering_fields = ['created_at', 'rating']
    ordering = ['-created_at']
    filterset_fields = ['meal_plan_meal', 'rating']

    def get_queryset(self):
        """Return meal ratings for the current user."""
        return MealRating.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        """Set the user to the current user."""
        serializer.save(user=self.request.user)


class GroceryListViewSet(viewsets.ModelViewSet):
    """ViewSet for grocery lists."""
    serializer_class = GroceryListSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ['name']
    ordering_fields = ['created_at', 'week_start_date']
    ordering = ['-created_at']
    filterset_fields = ['meal_plan', 'is_completed']

    def get_queryset(self):
        """Return grocery lists for the current user."""
        return GroceryList.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        """Set the user to the current user."""
        serializer.save(user=self.request.user)


class RestaurantFoodViewSet(viewsets.ModelViewSet):
    """ViewSet for restaurant food items."""
    queryset = RestaurantFood.objects.all()
    serializer_class = RestaurantFoodSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ['restaurant_name', 'item_name', 'description']
    ordering_fields = ['restaurant_name', 'item_name', 'calories']
    ordering = ['restaurant_name', 'item_name']
    filterset_fields = ['restaurant_name', 'category']


class NutritionalAnalysisViewSet(viewsets.ModelViewSet):
    """ViewSet for nutritional analysis."""
    serializer_class = NutritionalAnalysisSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
    ordering_fields = ['analysis_date', 'created_at']
    ordering = ['-analysis_date']
    filterset_fields = ['analysis_type']

    def get_queryset(self):
        """Return nutritional analyses for the current user."""
        return NutritionalAnalysis.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        """Set the user to the current user."""
        serializer.save(user=self.request.user)


# ============================================================================
# NUTRITION ANALYTICS AND RECOMMENDATIONS API
# ============================================================================

class NutritionAnalyticsAPIView(APIView):
    """API endpoint for comprehensive nutrition analytics and recommendations."""
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        """Get nutrition analytics and recommendations for the user."""
        user = request.user
        
        # Get user's current nutrition goal
        try:
            current_goal = NutritionGoal.objects.filter(user=user, is_active=True).latest('created_at')
        except NutritionGoal.DoesNotExist:
            current_goal = None

        # Get recent nutrition logs (last 7 days)
        from datetime import date, timedelta
        week_ago = date.today() - timedelta(days=7)
        recent_logs = NutritionLog.objects.filter(
            user=user, 
            date__gte=week_ago
        ).order_by('-date')

        # Calculate daily averages
        daily_totals = {}
        for log in recent_logs:
            if log.date not in daily_totals:
                daily_totals[log.date] = {
                    'calories': 0, 'protein': 0, 'carbs': 0, 'fat': 0
                }
            daily_totals[log.date]['calories'] += log.calories
            daily_totals[log.date]['protein'] += log.protein_g
            daily_totals[log.date]['carbs'] += log.carbs_g
            daily_totals[log.date]['fat'] += log.fat_g

        # Calculate weekly averages
        if daily_totals:
            avg_calories = sum(d['calories'] for d in daily_totals.values()) / len(daily_totals)
            avg_protein = sum(d['protein'] for d in daily_totals.values()) / len(daily_totals)
            avg_carbs = sum(d['carbs'] for d in daily_totals.values()) / len(daily_totals)
            avg_fat = sum(d['fat'] for d in daily_totals.values()) / len(daily_totals)
        else:
            avg_calories = avg_protein = avg_carbs = avg_fat = 0

        # Generate recommendations
        recommendations = []
        if current_goal:
            if avg_calories < current_goal.target_calories * 0.9:
                recommendations.append("You're under-eating. Consider adding healthy snacks to meet your calorie target.")
            elif avg_calories > current_goal.target_calories * 1.1:
                recommendations.append("You're over-eating. Consider reducing portion sizes or choosing lower-calorie options.")
            
            if avg_protein < current_goal.target_protein_g * 0.9:
                recommendations.append("Increase protein intake with lean meats, fish, eggs, or plant-based proteins.")
            
            if avg_carbs > current_goal.target_carbs_g * 1.1:
                recommendations.append("Consider reducing refined carbs and focusing on complex carbohydrates.")

        # Get water intake for today
        today_water = WaterIntake.objects.filter(
            user=user, 
            date=date.today()
        ).aggregate(total=models.Sum('amount_ml'))['total'] or 0

        return Response({
            'current_goal': NutritionGoalSerializer(current_goal).data if current_goal else None,
            'weekly_averages': {
                'calories': round(avg_calories, 1),
                'protein_g': round(avg_protein, 1),
                'carbs_g': round(avg_carbs, 1),
                'fat_g': round(avg_fat, 1)
            },
            'daily_totals': daily_totals,
            'today_water_ml': today_water,
            'recommendations': recommendations,
            'analysis_date': date.today().isoformat()
        })


class MealPlanGeneratorAPIView(APIView):
    """API endpoint for generating personalized meal plans."""
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request):
        """Generate a meal plan based on user preferences and goals."""
        user = request.user
        data = request.data

        # Active nutrition goal required
        try:
            current_goal = NutritionGoal.objects.filter(user=user, is_active=True).latest('created_at')
        except NutritionGoal.DoesNotExist:
            return Response({'error': 'No active nutrition goal found'}, status=400)

        # Try to read trainer profile to override macros if provided
        trainer = TrainerProfile.objects.filter(user=user).first()
        kcal = current_goal.target_calories
        p = current_goal.target_protein_g
        c = current_goal.target_carbs_g
        f = current_goal.target_fat_g
        if trainer and trainer.macros:
            try:
                mp, mc, mf = [float(x) for x in trainer.macros.split('/')]
                total = mp + mc + mf
                if total > 0:
                    mp, mc, mf = mp/total, mc/total, mf/total
                    kcal = current_goal.target_calories
                    p = round((kcal * mp) / 4.0, 1)
                    c = round((kcal * mc) / 4.0, 1)
                    f = round((kcal * mf) / 9.0, 1)
            except Exception:
                pass

        meal_types = data.get('meal_types', ['breakfast', 'lunch', 'dinner'])
        days = int(data.get('days', 7))
        start = date.today()
        end = start + timedelta(days=days-1)

        # Persist plan
        plan = MealPlan.objects.create(
            user=user,
            name=data.get('name') or f'Personalized Meal Plan - {days} Days',
            description=f'Plan based on {current_goal.goal_type}',
            start_date=start,
            end_date=end,
            target_calories=kcal,
            target_protein_g=p,
            target_carbs_g=c,
            target_fat_g=f,
        )

        # Allocate per-meal targets evenly
        per_meal = len(meal_types) if meal_types else 3
        kcal_m = round(kcal / per_meal)
        p_m = round(p / per_meal, 1)
        c_m = round(c / per_meal, 1)
        f_m = round(f / per_meal, 1)

        for d in range(days):
            day_date = start + timedelta(days=d)
            day_name = day_date.strftime('%A')
            mpd = MealPlanDay.objects.create(
                meal_plan=plan,
                date=day_date,
                day_name=day_name,
                target_calories=kcal,
                target_protein_g=p,
                target_carbs_g=c,
                target_fat_g=f,
            )
            for mt in meal_types:
                MealPlanMeal.objects.create(
                    meal_plan_day=mpd,
                    meal_type=mt,
                    calories=kcal_m,
                    protein_g=p_m,
                    carbs_g=c_m,
                    fat_g=f_m,
                    notes='Auto-generated macro target meal'
                )

        return Response({
            'message': 'Meal plan generated',
            'meal_plan_id': plan.id,
            'start_date': start.isoformat(),
            'end_date': end.isoformat()
        }, status=201)


# ---------- Trainer config & contraindications ----------
class TrainerProfileViewSet(viewsets.ModelViewSet):
    permission_classes = [permissions.IsAuthenticated]
    serializer_class = TrainerProfileSerializer

    def get_queryset(self):
        return TrainerProfile.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        instance = serializer.save(user=self.request.user)
        return instance


class ExerciseContraindicationViewSet(viewsets.ModelViewSet):
    permission_classes = [permissions.IsAuthenticated]
    serializer_class = ExerciseContraindicationSerializer
    filter_backends = [DjangoFilterBackend, filters.SearchFilter]
    search_fields = ['injury_keyword', 'note']

    def get_queryset(self):
        return ExerciseContraindication.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        instance = serializer.save(user=self.request.user)
        return instance


# --------- User Profile Upsert ---------
class ProfileAPIView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        # Return current user's profile, creating a default if missing
        profile, _ = UserProfile.objects.get_or_create(user=request.user)
        data = UserProfileSerializer(profile).data
        return Response(data)

    def post(self, request):
        # Create or update all fields (upsert semantics)
        profile, _ = UserProfile.objects.get_or_create(user=request.user)
        serializer = UserProfileSerializer(instance=profile, data=request.data, partial=False)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=201)
        return Response({ 'error': 'Invalid profile data', 'details': serializer.errors }, status=400)

    def patch(self, request):
        profile, _ = UserProfile.objects.get_or_create(user=request.user)
        serializer = UserProfileSerializer(instance=profile, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response({ 'error': 'Invalid profile data', 'details': serializer.errors }, status=400)


# ---------- Account-level Onboarding ----------
class OnboardingStatusAPIView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        # Feature flag: disable onboarding globally
        if not settings.MAR_FLAGS.get('onboarding_enabled', True):
            return Response({'completed': True, 'completed_on': None, 'version': 'v1', 'current_step': None})
        profile, _ = UserProfile.objects.get_or_create(user=request.user)
        completed = bool(profile.completed_onboarding_at)
        current_step = None
        if isinstance(profile.onboarding_state, dict):
            current_step = profile.onboarding_state.get('current_step')
        data = {
            'completed': completed,
            'completed_on': profile.completed_onboarding_at,
            'version': profile.onboarding_version or 'v1',
            'current_step': current_step,
        }
        return Response(data)


class OnboardingQuestionsAPIView(APIView):
    permission_classes = [permissions.IsAuthenticated]
    throttle_classes = [ScopedRateThrottle]
    throttle_scope = 'onboarding'

    def get(self, request):
        payload = {
            'version': 'v1',
            'steps': [
                {
                    'id': 'goals',
                    'questions': [
                        {'id': 'primary_goal', 'type': 'enum', 'choices': ['fat_loss', 'muscle_gain', 'endurance'], 'required': True},
                        {'id': 'target_days', 'type': 'int', 'min': 2, 'max': 7, 'required': True},
                    ],
                },
                {
                    'id': 'equipment',
                    'questions': [
                        {'id': 'available', 'type': 'multi', 'choices': ['dumbbells', 'barbell', 'bands', 'bodyweight']},
                    ],
                },
            ],
        }
        # Simple ETag support
        import hashlib, json
        etag = hashlib.sha1(json.dumps(payload, sort_keys=True).encode()).hexdigest()
        inm = request.headers.get('If-None-Match')
        if inm == etag:
            return Response(status=304)
        resp = Response(payload)
        resp['ETag'] = etag
        resp['Cache-Control'] = 'public, max-age=3600'
        return resp


class OnboardingAnswersAPIView(APIView):
    permission_classes = [permissions.IsAuthenticated]
    throttle_classes = [ScopedRateThrottle]
    throttle_scope = 'onboarding'

    def post(self, request):
        if not settings.MAR_FLAGS.get('onboarding_enabled', True):
            return Response({'saved': True, 'next_step': None})
        # Idempotency support
        idem = request.headers.get('Idempotency-Key')
        if idem:
            cached = cache.get(idem)
            if cached:
                return Response(cached['payload'], status=cached['status'])
        ser = OnboardingAnswersSerializer(data=request.data)
        ser.is_valid(raise_exception=True)
        version = ser.validated_data['version']
        step = ser.validated_data['step']
        answers = ser.validated_data['answers']

        # Server-side validation for v1
        if step == 'goals':
            pg = answers.get('primary_goal')
            td = answers.get('target_days')
            if pg not in ['fat_loss', 'muscle_gain', 'endurance']:
                return Response({'detail': 'invalid_primary_goal'}, status=400)
            try:
                td = int(td)
            except Exception:
                return Response({'detail': 'invalid_target_days'}, status=400)
            if td < 2 or td > 7:
                return Response({'detail': 'target_days_out_of_range'}, status=400)

        profile, _ = UserProfile.objects.get_or_create(user=request.user)
        state = profile.onboarding_state or {}
        state.setdefault('answers', {})
        state['answers'][step] = answers
        # simple linear flow example
        next_step = 'preferences' if step == 'goals' else None
        state['current_step'] = next_step
        profile.onboarding_state = state
        profile.onboarding_version = version
        profile.save(update_fields=['onboarding_state', 'onboarding_version'])
        resp = {'saved': True, 'next_step': next_step}
        if idem:
            cache.set(idem, {'status': 200, 'payload': resp}, timeout=300)
        return Response(resp)


class OnboardingCompleteAPIView(APIView):
    permission_classes = [permissions.IsAuthenticated]
    throttle_classes = [ScopedRateThrottle]
    throttle_scope = 'onboarding'

    def post(self, request):
        if not settings.MAR_FLAGS.get('onboarding_enabled', True):
            return Response({'completed': True, 'completed_on': None})
        # Idempotency support
        idem = request.headers.get('Idempotency-Key')
        if idem:
            cached = cache.get(idem)
            if cached:
                return Response(cached['payload'], status=cached['status'])
        profile, _ = UserProfile.objects.get_or_create(user=request.user)
        answers = (profile.onboarding_state or {}).get('answers')
        if not answers:
            return Response({'completed': False, 'message': 'answers_missing'}, status=400)
        profile.onboarding_answers = answers
        profile.completed_onboarding_at = timezone.now()
        profile.onboarding_state = None
        profile.save(update_fields=['onboarding_answers', 'completed_onboarding_at', 'onboarding_state'])
        payload = {'completed': True, 'completed_on': profile.completed_onboarding_at}
        if idem:
            cache.set(idem, {'status': 200, 'payload': payload}, timeout=300)
        return Response(payload)


class OnboardingResetAPIView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request):
        if not request.user.is_staff:
            return Response({'detail': 'forbidden'}, status=403)
        user_id = request.data.get('user_id') or request.user.id
        try:
            profile = UserProfile.objects.get(user_id=user_id)
        except UserProfile.DoesNotExist:
            return Response({'detail': 'profile_not_found'}, status=404)
        profile.completed_onboarding_at = None
        profile.onboarding_state = None
        profile.onboarding_answers = None
        profile.save(update_fields=['completed_onboarding_at', 'onboarding_state', 'onboarding_answers'])
        return Response({'reset': True})
