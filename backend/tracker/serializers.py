# Generated by Cursor AI for Maverick Aim Rush
# Serializers for Maverick Aim Rush â€” created by Cursor AI

from rest_framework import serializers
from django.contrib.auth.models import User
from .models import (
    Goal, BodyMeasurement, ExerciseCatalog, WorkoutSession, StrengthSet,
    CardioEntry, NutritionLog, SleepLog, InjuryLog, Plan, PlannedExercise,
    FoodCatalog, Muscle, Equipment, Tag, ExerciseMuscle
)

class UserSerializer(serializers.ModelSerializer):
    """Serializer for the User model, used for registration."""
    class Meta:
        model = User
        fields = ('id', 'username', 'password', 'email')
        extra_kwargs = {'password': {'write_only': True}}

    def create(self, validated_data):
        user = User.objects.create_user(
            validated_data['username'],
            validated_data.get('email', ''),
            validated_data['password']
        )
        return user

class StrengthSetSerializer(serializers.ModelSerializer):
    exercise_id = serializers.ReadOnlyField(source='exercise.id')
    class Meta:
        model = StrengthSet
        fields = '__all__'

class CardioEntrySerializer(serializers.ModelSerializer):
    class Meta:
        model = CardioEntry
        fields = '__all__'

class WorkoutSessionSerializer(serializers.ModelSerializer):
    strength_sets = StrengthSetSerializer(many=True, read_only=True)
    cardio_entries = CardioEntrySerializer(many=True, read_only=True)

    class Meta:
        model = WorkoutSession
        fields = ('id', 'user', 'date', 'duration_minutes', 'notes', 'strength_sets', 'cardio_entries')
        read_only_fields = ('user',)

class PlannedExerciseSerializer(serializers.ModelSerializer):
    class Meta:
        model = PlannedExercise
        fields = '__all__'

class PlanSerializer(serializers.ModelSerializer):
    planned_exercises = PlannedExerciseSerializer(many=True)

    class Meta:
        model = Plan
        fields = ('id', 'user', 'name', 'start_date', 'end_date', 'planned_exercises')
        read_only_fields = ('user',)

    def create(self, validated_data):
        planned_exercises_data = validated_data.pop('planned_exercises')
        plan = Plan.objects.create(**validated_data)
        for exercise_data in planned_exercises_data:
            PlannedExercise.objects.create(plan=plan, **exercise_data)
        return plan

class ExerciseCatalogSerializer(serializers.ModelSerializer):
    muscles = serializers.SerializerMethodField()
    equipments = serializers.SlugRelatedField(slug_field='name', many=True, read_only=True)
    tags = serializers.SlugRelatedField(slug_field='name', many=True, read_only=True)

    class Meta:
        model = ExerciseCatalog
        fields = (
            'id', 'name', 'category', 'equipment_needed', 'target_muscle_groups',
            'difficulty_level', 'recommended_for_goal', 'description',
            'muscles', 'equipments', 'tags'
        )

    def get_muscles(self, obj):
        # Return primary/secondary split
        primaries = ExerciseMuscle.objects.filter(exercise=obj, role='primary').select_related('muscle')
        secondaries = ExerciseMuscle.objects.filter(exercise=obj, role='secondary').select_related('muscle')
        return {
            'primary': [em.muscle.name for em in primaries],
            'secondary': [em.muscle.name for em in secondaries]
        }

class MuscleSerializer(serializers.ModelSerializer):
    class Meta:
        model = Muscle
        fields = ('id', 'name', 'group')

class EquipmentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Equipment
        fields = ('id', 'name')

class TagSerializer(serializers.ModelSerializer):
    class Meta:
        model = Tag
        fields = ('id', 'name', 'type')

class FoodCatalogSerializer(serializers.ModelSerializer):
    class Meta:
        model = FoodCatalog
        fields = '__all__'

class GoalSerializer(serializers.ModelSerializer):
    class Meta:
        model = Goal
        fields = '__all__'
        read_only_fields = ('user',)

class BodyMeasurementSerializer(serializers.ModelSerializer):
    bmi = serializers.SerializerMethodField()
    class Meta:
        model = BodyMeasurement
        fields = '__all__'
        read_only_fields = ('user',)

    def get_bmi(self, obj):
        return obj.bmi

class NutritionLogSerializer(serializers.ModelSerializer):
    class Meta:
        model = NutritionLog
        fields = '__all__'
        read_only_fields = ('user',)

    def validate(self, attrs):
        """
        If only food_item and quantity_grams are provided, fill in calories/macros
        using FoodCatalog per-100g values.
        """
        food_item = attrs.get('food_item')
        quantity_grams = attrs.get('quantity_grams')

        # Accept a loose 'quantity' string (e.g., "150g" or "150 g") from clients
        # and parse grams if quantity_grams wasn't explicitly provided.
        if quantity_grams in (None, ""):
            raw_quantity = self.initial_data.get('quantity') if hasattr(self, 'initial_data') else None
            if isinstance(raw_quantity, str):
                import re
                match = re.search(r"(\d+(?:\.\d+)?)\s*(g|gram|grams|kg)?", raw_quantity.lower())
                if match:
                    value = float(match.group(1))
                    unit = match.group(2) or 'g'
                    if unit == 'kg':
                        value *= 1000
                    attrs['quantity_grams'] = value
                    quantity_grams = value

        calories = attrs.get('calories')
        protein_g = attrs.get('protein_g')
        carbs_g = attrs.get('carbs_g')
        fat_g = attrs.get('fat_g')

        # If calories are missing or zero and we have a food match + quantity, compute
        if food_item and quantity_grams and (calories is None or calories == 0):
            # Try exact match first, then fallback to icontains
            food = None
            try:
                food = FoodCatalog.objects.get(name__iexact=food_item)
            except FoodCatalog.DoesNotExist:
                candidates = FoodCatalog.objects.filter(name__icontains=food_item).order_by('name')
                if candidates.exists():
                    food = candidates.first()

            if food is not None:
                factor = float(quantity_grams) / 100.0
                attrs['calories'] = int(round(food.calories_per_100g * factor))
                attrs['protein_g'] = round(food.protein_g_per_100g * factor, 1)
                attrs['carbs_g'] = round(food.carbs_g_per_100g * factor, 1)
                attrs['fat_g'] = round(food.fat_g_per_100g * factor, 1)

        return attrs

class SleepLogSerializer(serializers.ModelSerializer):
    class Meta:
        model = SleepLog
        fields = '__all__'
        read_only_fields = ('user',)

class InjuryLogSerializer(serializers.ModelSerializer):
    class Meta:
        model = InjuryLog
        fields = '__all__'
        read_only_fields = ('user',)
