# Generated by Cursor AI for Maverick Aim Rush
# WebSocket consumers for real-time features

import json
import asyncio
import time
import uuid
from collections import defaultdict, deque
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.contrib.auth.models import User
from .models import WorkoutSession, StrengthSet
from django.utils import timezone
from django.db import connection
from django.conf import settings


class WorkoutConsumer(AsyncWebsocketConsumer):
    """Real-time workout session consumer with reconciliation and HR aggregation"""
    
    # Class-level variables for HR aggregation
    HR_BUF = defaultdict(lambda: deque(maxlen=10))  # 10 samples per user
    HR_WIN_MS = 1000  # 1 second window
    MAX_QUEUE = 100  # Max queued messages per user
    recent_ids = defaultdict(set)  # Track recent message IDs for idempotency
    
    async def connect(self):
        # Check authentication
        if not self.scope["user"].is_authenticated:
            await self.send_error("unauthorized", "Authentication required")
            await self.close()
            return
            
        self.session_id = self.scope['url_route']['kwargs']['session_id']
        self.user_id = self.scope["user"].id
        self.room_group_name = f'workout_{self.session_id}'
        self.server_seq = 0  # Server-side sequence number
        
        # Join room group
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        
        await self.accept()
        
        # Send initial workout state
        await self.send_workout_state()
    
    async def disconnect(self, close_code):
        # Leave room group
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )
    
    async def receive(self, text_data):
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            client_msg_id = data.get('client_msg_id')
            
            # Check for idempotency
            if client_msg_id and client_msg_id in self.recent_ids[self.user_id]:
                return  # Duplicate message, ignore
            
            # Add to recent IDs (keep last 1000)
            if client_msg_id:
                self.recent_ids[self.user_id].add(client_msg_id)
                if len(self.recent_ids[self.user_id]) > 1000:
                    # Remove oldest IDs (simple cleanup)
                    self.recent_ids[self.user_id] = set(list(self.recent_ids[self.user_id])[-500:])
            
            if message_type == 'set_completed':
                await self.handle_set_completed(data)
            elif message_type == 'heart_rate':
                await self.handle_heart_rate(data)
            elif message_type == 'workout_paused':
                await self.handle_workout_paused(data)
            elif message_type == 'workout_resumed':
                await self.handle_workout_resumed(data)
                
        except json.JSONDecodeError:
            await self.send_error("invalid_json", "Invalid JSON format")
        except Exception as e:
            await self.send_error("internal_error", f"Internal error: {str(e)}")
    
    async def send_error(self, code, message):
        """Send standardized error message"""
        correlation_id = str(uuid.uuid4())
        await self.send(text_data=json.dumps({
            'type': 'error',
            'code': code,
            'message': message,
            'correlation_id': correlation_id,
            'server_seq': self.server_seq
        }))
    
    async def handle_set_completed(self, data):
        """Handle completed set data"""
        set_data = data.get('set', {})
        
        # Save set to database
        await self.save_strength_set(set_data)
        
        # Increment server sequence
        self.server_seq += 1
        
        # Broadcast to group with server sequence
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'set_update',
                'set': set_data,
                'server_seq': self.server_seq
            }
        )
    
    async def handle_heart_rate(self, data):
        """Handle heart rate data with 1-second aggregation"""
        hr_data = data.get('heart_rate', {})
        heart_rate = hr_data.get('heart_rate')
        timestamp = hr_data.get('timestamp', time.time())
        
        if heart_rate is not None:
            # Add to aggregation buffer
            self.HR_BUF[self.user_id].append({
                'heart_rate': heart_rate,
                'timestamp': timestamp
            })
            
            # Check if we should emit aggregated data (1-second window)
            current_time = time.time()
            window_start = current_time - (self.HR_WIN_MS / 1000.0)
            
            # Filter samples within the window
            recent_samples = [
                sample for sample in self.HR_BUF[self.user_id]
                if sample['timestamp'] >= window_start
            ]
            
            if recent_samples:
                # Calculate average HR for the window
                avg_hr = sum(s['heart_rate'] for s in recent_samples) / len(recent_samples)
                max_hr = max(s['heart_rate'] for s in recent_samples)
                
                # Save to database (async)
                await self.save_hr_sample(heart_rate, timestamp)
                
                # Increment server sequence
                self.server_seq += 1
                
                # Broadcast aggregated data
                await self.channel_layer.group_send(
                    self.room_group_name,
                    {
                        'type': 'heart_rate_update',
                        'heart_rate': {
                            'heart_rate': int(avg_hr),
                            'max_hr': int(max_hr),
                            'samples_count': len(recent_samples),
                            'timestamp': current_time
                        },
                        'server_seq': self.server_seq
                    }
                )
    
    async def handle_workout_paused(self, data):
        """Handle workout pause"""
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'workout_paused',
                'timestamp': timezone.now().isoformat()
            }
        )
    
    async def handle_workout_resumed(self, data):
        """Handle workout resume"""
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'workout_resumed',
                'timestamp': timezone.now().isoformat()
            }
        )
    
    async def send_workout_state(self):
        """Send current workout state to client"""
        session_data = await self.get_workout_session()
        await self.send(text_data=json.dumps({
            'type': 'workout_state',
            'session': session_data
        }))
    
    async def set_update(self, event):
        """Send set update to WebSocket"""
        await self.send(text_data=json.dumps({
            'type': 'set_update',
            'set': event['set'],
            'server_seq': event.get('server_seq', 0)
        }))
    
    async def heart_rate_update(self, event):
        """Send heart rate update to WebSocket"""
        await self.send(text_data=json.dumps({
            'type': 'heart_rate_update',
            'heart_rate': event['heart_rate'],
            'server_seq': event.get('server_seq', 0)
        }))
    
    async def workout_paused(self, event):
        """Send workout paused to WebSocket"""
        await self.send(text_data=json.dumps({
            'type': 'workout_paused',
            'timestamp': event['timestamp']
        }))
    
    async def workout_resumed(self, event):
        """Send workout resumed to WebSocket"""
        await self.send(text_data=json.dumps({
            'type': 'workout_resumed',
            'timestamp': event['timestamp']
        }))
    
    @database_sync_to_async
    def get_workout_session(self):
        """Get workout session data"""
        try:
            session = WorkoutSession.objects.get(id=self.session_id)
            return {
                'id': session.id,
                'start_time': session.start_time.isoformat() if session.start_time else None,
                'end_time': session.end_time.isoformat() if session.end_time else None,
                'status': 'active' if not session.end_time else 'completed'
            }
        except WorkoutSession.DoesNotExist:
            return None
    
    @database_sync_to_async
    def save_strength_set(self, set_data):
        """Save strength set to database"""
        try:
            session = WorkoutSession.objects.get(id=self.session_id)
            StrengthSet.objects.create(
                session=session,
                exercise_name=set_data.get('exercise_name', ''),
                weight_kg=set_data.get('weight_kg', 0),
                repetitions=set_data.get('repetitions', 0),
                notes=set_data.get('notes', '')
            )
        except WorkoutSession.DoesNotExist:
            pass
    
    @database_sync_to_async
    def save_hr_sample(self, heart_rate, timestamp):
        """Save heart rate sample to database"""
        try:
            from django.utils import timezone
            from datetime import datetime
            
            # Convert timestamp to timezone-aware datetime
            if isinstance(timestamp, (int, float)):
                dt = datetime.fromtimestamp(timestamp, tz=timezone.utc)
            else:
                dt = timezone.now()
            
            # Insert into materialized view table
            with connection.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO tracker_hr_sample (user_id, session_id, timestamp, heart_rate, device_id)
                    VALUES (%s, %s, %s, %s, %s)
                """, [self.user_id, self.session_id, dt, heart_rate, 'websocket'])
                
        except Exception as e:
            # Log error but don't fail the WebSocket connection
            print(f"Error saving HR sample: {e}")
            pass


class DashboardConsumer(AsyncWebsocketConsumer):
    """Real-time dashboard consumer with authentication"""
    
    async def connect(self):
        # Check authentication
        if not self.scope["user"].is_authenticated:
            await self.send_error("unauthorized", "Authentication required")
            await self.close()
            return
            
        self.user_id = self.scope["user"].id
        self.room_group_name = f'dashboard_{self.user_id}'
        self.server_seq = 0
        
        # Join room group
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        
        await self.accept()
        
        # Send initial dashboard data
        await self.send_dashboard_data()
    
    async def disconnect(self, close_code):
        # Leave room group
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )
    
    async def receive(self, text_data):
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            
            if message_type == 'request_update':
                await self.send_dashboard_data()
                
        except json.JSONDecodeError:
            await self.send_error("invalid_json", "Invalid JSON format")
        except Exception as e:
            await self.send_error("internal_error", f"Internal error: {str(e)}")
    
    async def send_error(self, code, message):
        """Send standardized error message"""
        correlation_id = str(uuid.uuid4())
        await self.send(text_data=json.dumps({
            'type': 'error',
            'code': code,
            'message': message,
            'correlation_id': correlation_id,
            'server_seq': self.server_seq
        }))
    
    async def send_dashboard_data(self):
        """Send current dashboard data"""
        dashboard_data = await self.get_dashboard_data()
        await self.send(text_data=json.dumps({
            'type': 'dashboard_update',
            'data': dashboard_data
        }))
    
    async def dashboard_update(self, event):
        """Send dashboard update to WebSocket"""
        await self.send(text_data=json.dumps({
            'type': 'dashboard_update',
            'data': event['data']
        }))
    
    @database_sync_to_async
    def get_dashboard_data(self):
        """Get dashboard data for user"""
        try:
            user = User.objects.get(id=self.user_id)
            
            # Get recent sessions
            recent_sessions = WorkoutSession.objects.filter(
                user=user
            ).order_by('-start_time')[:5]
            
            sessions_data = []
            for session in recent_sessions:
                sessions_data.append({
                    'id': session.id,
                    'start_time': session.start_time.isoformat() if session.start_time else None,
                    'duration_minutes': session.duration_minutes,
                    'title': getattr(session, 'title', 'Workout')
                })
            
            return {
                'recent_sessions': sessions_data,
                'timestamp': timezone.now().isoformat()
            }
        except User.DoesNotExist:
            return {'error': 'User not found'}


class SocialConsumer(AsyncWebsocketConsumer):
    """Real-time social features consumer for friends, challenges, and leaderboards"""
    
    async def connect(self):
        # Check authentication
        if not self.scope["user"].is_authenticated:
            await self.send_error("unauthorized", "Authentication required")
            await self.close()
            return
            
        self.user_id = self.scope["user"].id
        self.username = self.scope["user"].username
        self.room_group_name = f'social_{self.user_id}'
        self.server_seq = 0
        
        # Join user's social group
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        
        # Join friends' activity groups for real-time updates
        await self.join_friends_groups()
        
        await self.accept()
        
        # Send initial social data
        await self.send_social_data()
    
    async def disconnect(self, close_code):
        # Leave room group
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )
        
        # Leave friends' groups
        await self.leave_friends_groups()
    
    async def receive(self, text_data):
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            
            if message_type == 'request_update':
                await self.send_social_data()
            elif message_type == 'like_activity':
                await self.handle_like_activity(data)
            elif message_type == 'comment_activity':
                await self.handle_comment_activity(data)
            elif message_type == 'join_challenge':
                await self.handle_join_challenge(data)
                
        except json.JSONDecodeError:
            await self.send_error("invalid_json", "Invalid JSON format")
        except Exception as e:
            await self.send_error("internal_error", f"Internal error: {str(e)}")
    
    async def send_error(self, code, message):
        """Send standardized error message"""
        correlation_id = str(uuid.uuid4())
        await self.send(text_data=json.dumps({
            'type': 'error',
            'code': code,
            'message': message,
            'correlation_id': correlation_id,
            'server_seq': self.server_seq
        }))
    
    async def join_friends_groups(self):
        """Join friends' activity groups for real-time updates"""
        friends = await self.get_user_friends()
        for friend in friends:
            friend_group = f'activity_{friend["id"]}'
            await self.channel_layer.group_add(
                friend_group,
                self.channel_name
            )
    
    async def leave_friends_groups(self):
        """Leave friends' activity groups"""
        friends = await self.get_user_friends()
        for friend in friends:
            friend_group = f'activity_{friend["id"]}'
            await self.channel_layer.group_discard(
                friend_group,
                self.channel_name
            )
    
    async def send_social_data(self):
        """Send current social data"""
        social_data = await self.get_social_data()
        await self.send(text_data=json.dumps({
            'type': 'social_data',
            'data': social_data
        }))
    
    async def handle_like_activity(self, data):
        """Handle liking a friend's activity"""
        activity_id = data.get('activity_id')
        if activity_id:
            # Save like to database
            await self.save_activity_like(activity_id)
            
            # Notify the activity owner
            activity_owner = await self.get_activity_owner(activity_id)
            if activity_owner:
                await self.channel_layer.group_send(
                    f'activity_{activity_owner}',
                    {
                        'type': 'activity_liked',
                        'activity_id': activity_id,
                        'liked_by': self.username,
                        'timestamp': timezone.now().isoformat()
                    }
                )
    
    async def handle_comment_activity(self, data):
        """Handle commenting on a friend's activity"""
        activity_id = data.get('activity_id')
        comment = data.get('comment', '')
        
        if activity_id and comment:
            # Save comment to database
            comment_id = await self.save_activity_comment(activity_id, comment)
            
            # Notify the activity owner
            activity_owner = await self.get_activity_owner(activity_id)
            if activity_owner:
                await self.channel_layer.group_send(
                    f'activity_{activity_owner}',
                    {
                        'type': 'activity_commented',
                        'activity_id': activity_id,
                        'comment_id': comment_id,
                        'comment': comment,
                        'commented_by': self.username,
                        'timestamp': timezone.now().isoformat()
                    }
                )
    
    async def handle_join_challenge(self, data):
        """Handle joining a challenge"""
        challenge_id = data.get('challenge_id')
        if challenge_id:
            # Join challenge in database
            result = await self.join_challenge_db(challenge_id)
            
            if result.get('success'):
                # Notify friends about challenge join
                await self.channel_layer.group_send(
                    self.room_group_name,
                    {
                        'type': 'challenge_joined',
                        'challenge_id': challenge_id,
                        'challenge_name': result.get('challenge_name'),
                        'timestamp': timezone.now().isoformat()
                    }
                )
    
    # Real-time event handlers
    async def friend_activity(self, event):
        """Handle friend activity updates"""
        await self.send(text_data=json.dumps({
            'type': 'friend_activity',
            'data': event['data'],
            'timestamp': event.get('timestamp')
        }))
    
    async def challenge_update(self, event):
        """Handle challenge progress updates"""
        await self.send(text_data=json.dumps({
            'type': 'challenge_update',
            'data': event['data'],
            'timestamp': event.get('timestamp')
        }))
    
    async def leaderboard_change(self, event):
        """Handle leaderboard ranking updates"""
        await self.send(text_data=json.dumps({
            'type': 'leaderboard_change',
            'data': event['data'],
            'timestamp': event.get('timestamp')
        }))
    
    async def achievement_unlock(self, event):
        """Handle achievement unlock notifications"""
        await self.send(text_data=json.dumps({
            'type': 'achievement_unlock',
            'data': event['data'],
            'timestamp': event.get('timestamp')
        }))
    
    async def activity_liked(self, event):
        """Handle activity like notifications"""
        await self.send(text_data=json.dumps({
            'type': 'activity_liked',
            'data': event,
            'timestamp': event.get('timestamp')
        }))
    
    async def activity_commented(self, event):
        """Handle activity comment notifications"""
        await self.send(text_data=json.dumps({
            'type': 'activity_commented',
            'data': event,
            'timestamp': event.get('timestamp')
        }))
    
    async def challenge_joined(self, event):
        """Handle challenge join notifications"""
        await self.send(text_data=json.dumps({
            'type': 'challenge_joined',
            'data': event,
            'timestamp': event.get('timestamp')
        }))
    
    # Database operations
    @database_sync_to_async
    def get_social_data(self):
        """Get current social data for user"""
        try:
            from .social import SocialFeatures
            social_engine = SocialFeatures(self.scope["user"])
            
            return {
                'friends': social_engine.get_friends(),
                'challenges': social_engine.get_my_challenges(),
                'achievements': social_engine.get_user_achievements(),
                'community_stats': social_engine.get_community_stats()
            }
        except Exception as e:
            return {'error': str(e)}
    
    @database_sync_to_async
    def get_user_friends(self):
        """Get user's friends list"""
        try:
            from .models import UserConnection
            friends = UserConnection.objects.filter(
                follower_id=self.user_id,
                connection_type='friend'
            ).select_related('following')
            
            return [
                {
                    'id': friend.following.id,
                    'username': friend.following.username
                }
                for friend in friends
            ]
        except Exception:
            return []
    
    @database_sync_to_async
    def save_activity_like(self, activity_id):
        """Save activity like to database"""
        try:
            from .models import ActivityLike
            like, created = ActivityLike.objects.get_or_create(
                user_id=self.user_id,
                activity_id=activity_id
            )
            return created
        except Exception:
            return False
    
    @database_sync_to_async
    def save_activity_comment(self, activity_id, comment):
        """Save activity comment to database"""
        try:
            from .models import ActivityComment
            comment_obj = ActivityComment.objects.create(
                user_id=self.user_id,
                activity_id=activity_id,
                comment=comment
            )
            return comment_obj.id
        except Exception:
            return None
    
    @database_sync_to_async
    def get_activity_owner(self, activity_id):
        """Get the owner of an activity"""
        try:
            from .models import Activity
            activity = Activity.objects.get(id=activity_id)
            return activity.user_id
        except Exception:
            return None
    
    @database_sync_to_async
    def join_challenge_db(self, challenge_id):
        """Join a challenge in database"""
        try:
            from .social import SocialFeatures
            social_engine = SocialFeatures(self.scope["user"])
            result = social_engine.join_challenge(challenge_id)
            return result
        except Exception as e:
            return {'error': str(e)}


class TestConsumer(AsyncWebsocketConsumer):
    """Simple test consumer for WebSocket connectivity testing"""

    async def connect(self):
        await self.accept()
        await self.send(text_data=json.dumps({
            'type': 'connection_established',
            'message': 'WebSocket connection successful!',
            'timestamp': timezone.now().isoformat()
        }))

    async def disconnect(self, close_code):
        pass

    async def receive(self, text_data):
        try:
            data = json.loads(text_data)
            message_type = data.get('type', 'unknown')
            
            await self.send(text_data=json.dumps({
                'type': 'echo',
                'original_type': message_type,
                'message': f'Received: {data.get("data", "No data")}',
                'timestamp': timezone.now().isoformat()
            }))
            
        except json.JSONDecodeError:
            await self.send(text_data=json.dumps({
                'type': 'error',
                'message': 'Invalid JSON format',
                'timestamp': timezone.now().isoformat()
            }))


class SimpleTestConsumer(AsyncWebsocketConsumer):
    """Simple test consumer without authentication for basic connectivity testing"""

    async def connect(self):
        await self.accept()
        await self.send(text_data=json.dumps({
            'type': 'connection_established',
            'message': 'Simple WebSocket connection successful!',
            'timestamp': timezone.now().isoformat()
        }))

    async def disconnect(self, close_code):
        pass

    async def receive(self, text_data):
        try:
            data = json.loads(text_data)
            message_type = data.get('type', 'unknown')
            
            await self.send(text_data=json.dumps({
                'type': 'echo',
                'original_type': message_type,
                'message': f'Received: {data.get("data", "No data")}',
                'timestamp': timezone.now().isoformat()
            }))
            
        except json.JSONDecodeError:
            await self.send(text_data=json.dumps({
                'type': 'error',
                'message': 'Invalid JSON format',
                'timestamp': timezone.now().isoformat()
            }))
